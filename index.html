<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AI Compass ‚Äî –∫–∞—Ä—Ç–∞ –®–Ü —Å–µ—Ä–≤—ñ—Å—ñ–≤</title>
  <link
    rel="icon"
    type="image/svg+xml"
    href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0' stop-color='%231e3a8a'/%3E%3Cstop offset='1' stop-color='%230ea5e9'/%3E%3C/linearGradient%3E%3C/defs%3E%3Ccircle cx='32' cy='32' r='30' fill='url(%23g)'/%3E%3Cpolygon points='32,14 41,32 32,50 23,32' fill='%23f8fafc'/%3E%3Ccircle cx='32' cy='32' r='6' fill='%231f2937'/%3E%3C/svg%3E"
  />
  <style>
    html,
    body {
      height: 100%;
    }
    body {
      --color-body-bg: #0b1120;
      --color-text-primary: #e2e8f0;
      --color-top-banner-bg: #0f172a;
      --color-top-banner-text: #e2e8f0;
      --color-top-banner-border: rgba(148, 163, 184, 0.18);
      --color-banner-pill-bg: rgba(148, 163, 184, 0.22);
      --color-banner-pill-text: #bae6fd;
      --color-hero-bg: linear-gradient(135deg, #0b1120 0%, #1e293b 100%);
      --color-hero-border: rgba(148, 163, 184, 0.22);
      --color-hero-title: #f8fafc;
      --color-hero-subtitle: #cbd5f5;
      --color-hero-description: #94a3b8;
      --color-map-heading: #e2e8f0;
      --color-search-bg: #111827;
      --color-search-border: rgba(148, 163, 184, 0.4);
      --color-search-text: #e2e8f0;
      --color-search-placeholder: #64748b;
      --color-search-focus: #60a5fa;
      --color-search-focus-ring: rgba(96, 165, 250, 0.28);
      --color-button-bg: #1e293b;
      --color-button-text: #e2e8f0;
      --color-button-hover-bg: #273449;
      --color-button-active-bg: #2563eb;
      --color-button-active-text: #f8fafc;
      --color-button-active-shadow: rgba(37, 99, 235, 0.35);
      --color-card-bg: #111827;
      --color-card-border: rgba(148, 163, 184, 0.25);
      --color-card-shadow: 0 12px 32px rgba(2, 6, 23, 0.7);
      --info-note-color: #94a3b8;
      --color-footer-bg: #020617;
      --color-footer-text: #cbd5f5;
      --color-footer-border: rgba(148, 163, 184, 0.18);
      --color-footer-title: #f8fafc;
      --surface-color: #0f172a;
      --surface-border: rgba(148, 163, 184, 0.35);
      --node-text: #f8fafc;
      --muted-text: #94a3b8;
      --link-text: #60a5fa;
      --error-text: #fca5a5;
      --tooltip-bg: #020617;
      --tooltip-text: #f8fafc;
      margin: 0;
      min-height: 100%;
      display: flex;
      flex-direction: column;
      background: var(--color-body-bg);
      color: var(--color-text-primary);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      transition: background 0.3s ease, color 0.3s ease;
    }
    body[data-theme="dark"] {
      color-scheme: dark;
    }
    body[data-theme="light"] {
      color-scheme: light;
      --color-body-bg: #f9fafb;
      --color-text-primary: #111827;
      --color-top-banner-bg: #1f2937;
      --color-top-banner-text: #f9fafb;
      --color-top-banner-border: rgba(255, 255, 255, 0.08);
      --color-banner-pill-bg: rgba(255, 255, 255, 0.12);
      --color-banner-pill-text: #e0f2fe;
      --color-hero-bg: linear-gradient(135deg, #dbeafe 0%, #f8fafc 100%);
      --color-hero-border: #e5e7eb;
      --color-hero-title: #0f172a;
      --color-hero-subtitle: #1f2937;
      --color-hero-description: #374151;
      --color-map-heading: #0f172a;
      --color-search-bg: #fff;
      --color-search-border: #d1d5db;
      --color-search-text: #0f172a;
      --color-search-placeholder: #9ca3af;
      --color-search-focus: #2563eb;
      --color-search-focus-ring: rgba(37, 99, 235, 0.14);
      --color-button-bg: #e5e7eb;
      --color-button-text: #1f2937;
      --color-button-hover-bg: #d1d5db;
      --color-button-active-bg: #2563eb;
      --color-button-active-text: #fff;
      --color-button-active-shadow: rgba(37, 99, 235, 0.18);
      --color-card-bg: #fff;
      --color-card-border: #e5e7eb;
      --color-card-shadow: 0 12px 32px rgba(15, 23, 42, 0.12);
      --info-note-color: #4b5563;
      --color-footer-bg: #0f172a;
      --color-footer-text: #e5e7eb;
      --color-footer-border: rgba(255, 255, 255, 0.08);
      --color-footer-title: #f9fafb;
      --surface-color: #fff;
      --surface-border: #d1d5db;
      --node-text: #111827;
      --muted-text: #e5e7eb;
      --link-text: #60a5fa;
      --error-text: #b91c1c;
      --tooltip-bg: #111827;
      --tooltip-text: #fff;
    }
    main {
      flex: 1;
    }
    .wrap {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 16px;
      box-sizing: border-box;
    }
    .top-banner {
      background: var(--color-top-banner-bg);
      color: var(--color-top-banner-text);
      border-bottom: 1px solid var(--color-top-banner-border);
      transition: background 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }
    .banner-inner {
      padding: 10px 16px;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 13px;
      letter-spacing: 0.01em;
      text-align: center;
    }
    .banner-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px 10px;
      border-radius: 999px;
      background: var(--color-banner-pill-bg);
      color: var(--color-banner-pill-text);
      font-weight: 600;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      transition: background 0.3s ease, color 0.3s ease;
    }
    .hero {
      background: var(--color-hero-bg);
      border-bottom: 1px solid var(--color-hero-border);
      transition: background 0.3s ease, border-color 0.3s ease;
    }
    .hero-inner {
      padding: 48px 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: flex-start;
    }
    .hero-label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: #1d4ed8;
      color: #fff;
      padding: 6px 14px;
      border-radius: 999px;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }
    .hero-title {
      margin: 0;
      font-size: 32px;
      line-height: 1.2;
      font-weight: 700;
      color: var(--color-hero-title);
      transition: color 0.3s ease;
    }
    .hero-subtitle {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: var(--color-hero-subtitle);
      transition: color 0.3s ease;
    }
    .hero-description {
      margin: 0;
      max-width: 640px;
      font-size: 15px;
      line-height: 1.6;
      color: var(--color-hero-description);
      transition: color 0.3s ease;
    }
    .main-content {
      padding: 40px 16px 48px;
    }
    .bar {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      margin-bottom: 18px;
      flex-wrap: wrap;
      gap: 12px;
    }
    .bar-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .search-input {
      flex: 1 1 240px;
      min-width: 160px;
      width: min(100%, 320px);
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid var(--color-search-border);
      background: var(--color-search-bg);
      color: var(--color-search-text);
      font-size: 14px;
      line-height: 1.4;
      transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
      box-sizing: border-box;
    }
    .search-input::placeholder {
      color: var(--color-search-placeholder);
    }
    .search-input:focus {
      outline: none;
      border-color: var(--color-search-focus);
      box-shadow: 0 0 0 3px var(--color-search-focus-ring);
    }
    .map-heading {
      margin: 0;
      font-size: 22px;
      font-weight: 700;
      color: var(--color-map-heading);
      transition: color 0.3s ease;
    }
    .language-toggle {
      display: inline-flex;
      gap: 8px;
    }
    .theme-toggle {
      display: inline-flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .btn {
      border: 0;
      padding: 8px 14px;
      border-radius: 10px;
      cursor: pointer;
      background: var(--color-button-bg);
      font-size: 13px;
      font-weight: 600;
      color: var(--color-button-text);
      transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }
    .btn:hover {
      background: var(--color-button-hover-bg);
    }
    .btn.active {
      background: var(--color-button-active-bg);
      color: var(--color-button-active-text);
      box-shadow: 0 8px 16px var(--color-button-active-shadow);
    }
    .card {
      background: var(--color-card-bg);
      border-radius: 16px;
      box-shadow: var(--color-card-shadow);
      overflow: auto;
      border: 1px solid var(--color-card-border);
      transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
    }
    .content-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 24px;
      align-items: flex-start;
    }
    .map-column {
      flex: 1 1 600px;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .details-panel {
      flex: 0 1 340px;
      min-width: min(100%, 320px);
      background: var(--color-card-bg);
      border: 1px solid var(--color-card-border);
      border-radius: 16px;
      box-shadow: var(--color-card-shadow);
      padding: 20px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 16px;
      transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, color 0.3s ease;
    }
    .details-card {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .details-empty {
      font-size: 14px;
      line-height: 1.6;
      color: var(--info-note-color);
    }
    .details-header {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: flex-start;
    }
    .details-category {
      margin: 0;
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--info-note-color);
    }
    .details-title {
      margin: 4px 0 0;
      font-size: 20px;
      line-height: 1.3;
      color: var(--color-hero-title);
      transition: color 0.3s ease;
    }
    .details-description {
      margin: 0;
      font-size: 14px;
      line-height: 1.6;
      color: var(--color-text-primary);
    }
    .details-close {
      border: none;
      background: transparent;
      color: var(--info-note-color);
      font-size: 20px;
      line-height: 1;
      padding: 4px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .details-close:hover,
    .details-close:focus-visible {
      background: rgba(148, 163, 184, 0.18);
      color: var(--color-text-primary);
      outline: none;
    }
    .details-section {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .details-section-title {
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--info-note-color);
    }
    .details-tag-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .details-tag-list li {
      padding: 4px 10px;
      border-radius: 999px;
      background: var(--color-banner-pill-bg);
      color: var(--color-banner-pill-text);
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.02em;
    }
    .details-link-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .details-link {
      display: inline-flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 10px;
      background: rgba(148, 163, 184, 0.16);
      color: var(--color-button-text);
      text-decoration: none;
      font-size: 13px;
      font-weight: 600;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .details-link:hover,
    .details-link:focus-visible {
      background: rgba(96, 165, 250, 0.2);
      color: var(--color-button-active-text);
      outline: none;
    }
    .details-primary {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 16px;
      border-radius: 12px;
      background: var(--color-button-active-bg);
      color: var(--color-button-active-text);
      font-weight: 700;
      text-decoration: none;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .details-primary:hover,
    .details-primary:focus-visible {
      background: #1d4ed8;
      transform: translateY(-1px);
      outline: none;
    }
    .is-hidden {
      display: none !important;
    }
    svg {
      display: block;
      width: 100%;
      height: auto;
      min-height: 640px;
    }
    .service-node ellipse {
      transition: transform 0.2s ease, stroke-width 0.2s ease, filter 0.2s ease;
    }
    .service-node.service-hover ellipse {
      stroke-width: 2.2 !important;
      filter: drop-shadow(0 6px 14px rgba(15, 23, 42, 0.45));
    }
    .service-node.service-selected ellipse {
      stroke-width: 2.6 !important;
      filter: drop-shadow(0 0 0 4px rgba(37, 99, 235, 0.35));
    }
    .info-note {
      color: var(--info-note-color);
      font-size: 13px;
      margin-top: 14px;
      line-height: 1.5;
      transition: color 0.3s ease;
    }
    .tip {
      pointer-events: none;
    }
    .small {
      font-size: 11px;
      font-weight: 600;
      fill: var(--node-text);
    }
    .normal {
      font-size: 12px;
      font-weight: 600;
      fill: var(--node-text);
    }
    .large {
      font-size: 16px;
      font-weight: 700;
      fill: var(--node-text);
    }
    .muted {
      font-size: 13px;
      font-weight: 500;
      fill: var(--muted-text);
    }
    .link {
      font-size: 11px;
      fill: var(--link-text);
      text-decoration: underline;
    }
    .search-hit text {
      font-weight: 700;
    }
    .search-hit ellipse {
      fill-opacity: 0.24;
      stroke-width: 2.6;
    }
    .site-footer {
      background: var(--color-footer-bg);
      color: var(--color-footer-text);
      padding: 28px 0;
      border-top: 1px solid var(--color-footer-border);
      transition: background 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }
    .footer-inner {
      padding: 0 16px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 13px;
      line-height: 1.6;
    }
    .footer-title {
      font-weight: 600;
      color: var(--color-footer-title);
      letter-spacing: 0.01em;
      transition: color 0.3s ease;
    }
    .footer-theme {
      margin-top: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    @media (max-width: 960px) {
      .content-grid {
        flex-direction: column;
      }
      .details-panel {
        width: 100%;
        min-width: 0;
      }
    }
    @media (max-width: 640px) {
      .hero-inner {
        padding: 36px 16px;
      }
      .bar-controls {
        width: 100%;
        justify-content: flex-start;
      }
      .search-input {
        flex: 1 1 100%;
        min-width: 0;
      }
      .hero-title {
        font-size: 26px;
      }
      .hero-subtitle {
        font-size: 16px;
      }
      .main-content {
        padding: 32px 16px 40px;
      }
      svg {
        min-height: 540px;
      }
    }
  </style>
</head>
<body data-theme="dark">
  <div class="top-banner">
    <div class="wrap banner-inner">
      <span class="banner-pill">AI Compass</span>
      <span id="bannerText">–ë—ñ–±–ª—ñ–æ—Ç–µ–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–µ–Ω–∏—Ö AI —Å–µ—Ä–≤—ñ—Å—ñ–≤ –¥–ª—è –º–∞—Ä–∫–µ—Ç–∏–Ω–≥—É, –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü—ñ—ó —Ç–∞ –∞–Ω–∞–ª—ñ—Ç–∏–∫–∏.</span>
    </div>
  </div>

  <header class="hero">
    <div class="wrap hero-inner">
      <span class="hero-label">AI Compass</span>
      <h1 id="heroTitle" class="hero-title">–í–∞—à –∫–æ–º–ø–∞—Å —É —Å–≤—ñ—Ç—ñ –®–Ü —Å–µ—Ä–≤—ñ—Å—ñ–≤</h1>
      <p id="heroSubtitle" class="hero-subtitle">–í—ñ–¥–∫—Ä–∏–≤–∞–π—Ç–µ –ø–µ—Ä–µ–≤—ñ—Ä–µ–Ω—ñ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏ –¥–ª—è –±—ñ–∑–Ω–µ—Å—É, —Ç–≤–æ—Ä—á–æ—Å—Ç—ñ –π –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü—ñ—ó.</p>
      <p id="heroDescription" class="hero-description">
        –ü–µ—Ä–µ–º–∏–∫–∞–π—Ç–µ –º–æ–≤—É, –æ–±–∏—Ä–∞–π—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é —Ç–∞ –≤—ñ–¥–∫—Ä–∏–≤–∞–π—Ç–µ –∫–∞—Ä—Ç–∫–∏ —Å–µ—Ä–≤—ñ—Å—ñ–≤ —ñ–∑ –æ–ø–∏—Å–æ–º, –ø–æ—Å–∏–ª–∞–Ω–Ω—è–º–∏ –π –∫–æ—Ä–∏—Å–Ω–∏–º–∏ –º–∞—Ç–µ—Ä—ñ–∞–ª–∞–º–∏.
      </p>
    </div>
  </header>

  <main>
    <div class="wrap main-content">
      <div class="bar">
        <h2 id="mapHeading" class="map-heading">–ú–∞–ø–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ–π AI‚Äë—Å–µ—Ä–≤—ñ—Å—ñ–≤</h2>
        <div class="bar-controls">
          <input
            id="searchInput"
            class="search-input"
            type="search"
            autocomplete="off"
            spellcheck="false"
            enterkeyhint="search"
          />
          <div class="language-toggle">
            <button id="uaBtn" class="btn active">UA</button>
            <button id="enBtn" class="btn">EN</button>
          </div>
          <div class="theme-toggle" data-theme-toggle="header">
            <button id="headerDarkBtn" class="btn" type="button" data-theme-option="dark">üåô –¢–µ–º–Ω–∞</button>
            <button id="headerLightBtn" class="btn" type="button" data-theme-option="light">‚òÄÔ∏è –°–≤—ñ—Ç–ª–∞</button>
          </div>
        </div>
      </div>
      <div class="content-grid">
        <div class="map-column">
          <div class="card">
            <svg id="stage" viewBox="0 0 1100 760" aria-label="Mind map canvas"></svg>
          </div>
          <p id="infoNote" class="info-note">
            –ö–ª—ñ–∫–Ω—ñ—Ç—å –∫–∞—Ç–µ–≥–æ—Ä—ñ—é, —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏ —Å–µ—Ä–≤—ñ—Å–∏, –∞ –ø–æ—Ç—ñ–º –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å –Ω–∞ –±—É–¥—å-—è–∫–∏–π –≤—É–∑–æ–ª, —â–æ–± –≤—ñ–¥–∫—Ä–∏—Ç–∏ –∫–∞—Ä—Ç–∫—É –∑ –æ–ø–∏—Å–æ–º —ñ –∫–æ—Ä–∏—Å–Ω–∏–º–∏ –ø–æ—Å–∏–ª–∞–Ω–Ω—è–º–∏.
          </p>
        </div>
        <aside id="detailsPanel" class="details-panel" aria-live="polite" aria-label="Service details">
          <div id="detailsEmpty" class="details-empty">
            <p id="detailsEmptyText">–û–±–µ—Ä–∏ —Å–µ—Ä–≤—ñ—Å, —â–æ–± –ø–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ –¥–µ—Ç–∞–ª—ñ.</p>
          </div>
          <article id="detailsCard" class="details-card is-hidden" aria-labelledby="detailsTitle">
            <header class="details-header">
              <div class="details-heading">
                <p id="detailsCategory" class="details-category"></p>
                <h3 id="detailsTitle" class="details-title"></h3>
              </div>
              <button id="detailsCloseBtn" class="details-close" type="button" aria-label="–ó–∞–∫—Ä–∏—Ç–∏ –∫–∞—Ä—Ç–∫—É">
                <span aria-hidden="true">√ó</span>
              </button>
            </header>
            <p id="detailsDescription" class="details-description"></p>
            <div id="detailsTagsSection" class="details-section is-hidden">
              <span id="detailsTagsLabel" class="details-section-title"></span>
              <ul id="detailsTagsList" class="details-tag-list"></ul>
            </div>
            <div id="detailsLinksSection" class="details-section is-hidden">
              <span id="detailsLinksLabel" class="details-section-title"></span>
              <div id="detailsLinksList" class="details-link-list"></div>
            </div>
            <a
              id="detailsPrimaryLink"
              class="details-primary is-hidden"
              target="_blank"
              rel="noreferrer"
              href="#"
            ></a>
          </article>
        </aside>
      </div>
    </div>
  </main>

  <footer class="site-footer">
    <div class="wrap footer-inner">
      <span class="footer-title">Dmytro Klevakin</span>
      <span id="footerRights">All rights reserved ¬∑ 2024</span>
      <span id="footerTagline">Crafted to help you explore and compare AI solutions with confidence.</span>
      <div class="footer-theme">
        <div class="theme-toggle" data-theme-toggle="footer">
          <button id="footerDarkBtn" class="btn" type="button" data-theme-option="dark">üåô –¢–µ–º–Ω–∞</button>
          <button id="footerLightBtn" class="btn" type="button" data-theme-option="light">‚òÄÔ∏è –°–≤—ñ—Ç–ª–∞</button>
        </div>
      </div>
    </div>
  </footer>

  <script>
    const datasetCache = new Map();
    const datasetPromises = new Map();
    const DATA_PATHS = {
      ua: 'data/ua.json',
      en: 'data/en.json',
    };

    function getDatasetPath(language) {
      return DATA_PATHS[language] || DATA_PATHS.ua;
    }

    async function loadDataset(language) {
      if (datasetCache.has(language)) {
        return datasetCache.get(language);
      }
      if (datasetPromises.has(language)) {
        return datasetPromises.get(language);
      }
      const pathValue = getDatasetPath(language);
      const promise = fetch(pathValue)
        .then((response) => {
          if (!response.ok) {
            throw new Error(`Failed to load dataset: ${response.status} ${response.statusText}`);
          }
          return response.json();
        })
        .then((json) => {
          datasetCache.set(language, json);
          datasetPromises.delete(language);
          return json;
        })
        .catch((error) => {
          datasetPromises.delete(language);
          throw error;
        });
      datasetPromises.set(language, promise);
      return promise;
    }

    const ICONS = {
      'ChatGPT': 'üß†',
      'Claude': 'ü™∂',
      'Google Gemini': '‚ú®',
      'Microsoft Copilot': 'üß≠',
      'Perplexity AI': 'üîé',
      'Mistral Le Chat': 'üå¨Ô∏è',
      'Pi by Inflection': 'üí¨',
      'You.com': 'üîç',
      'Character.AI': 'üé≠',
      'Midjourney': 'üé®',
      'Stable Diffusion': 'üåÄ',
      'Leonardo AI': 'üñåÔ∏è',
      'Canva AI': 'üñºÔ∏è',
      'Adobe Firefly': 'üî•',
      'Ideogram AI': 'üî§',
      'Playground AI': 'üõù',
      'DALL¬∑E': 'üß©',
      'Krea AI': 'üåà',
      'HeyGen': 'üó£Ô∏è',
      'Synthesia': 'üé¨',
      'Runway ML': 'üéûÔ∏è',
      'Pictory': 'ü™Ñ',
      'OpusClip': 'üì±',
      'Descript': 'üéôÔ∏è',
      'Lumen5': 'üìΩÔ∏è',
      'Rephrase.ai': 'üó£Ô∏è',
      'Fliki': 'üîä',
      'Zapier': '‚ö°',
      'Make': 'üß©',
      'n8n': 'ü™¢',
      'UiPath': 'üè≠',
      'Power Automate': 'üîÅ',
      'Bardeen': 'üõ†Ô∏è',
      'Levity': '‚öôÔ∏è',
      'Axiom.ai': 'üß™',
      'Workato': 'ü§ù',
      'Coursera': 'üéì',
      'Udemy': 'üìö',
      'Docebo': 'üè´',
      'LearnWorlds': 'üåê',
      'Evolv AI': 'üìà',
      'Mindsmith': 'üß†',
      'Sana AI': 'üí°',
      'Workera': 'üß¨',
      'CapCut': '‚úÇÔ∏è',
      'VEED.io': 'üìº',
      'Copy.ai': '‚úçÔ∏è',
      'Jasper': 'ü§ñ',
      'Notion AI': 'üóÉÔ∏è',
      'Predis.ai': 'üìù',
      'Tidio': 'üí¨',
      'ManyChat': 'ü§≥',
      'Writesonic': 'üöÄ',
      'Lately AI': 'üìä',
      'Power BI': 'üìä',
      'Tableau': 'üìà',
      'MonkeyLearn': 'üêí',
      'Crayon': 'üñçÔ∏è',
      'Crux': 'üß±',
      'Tellius': 'üîÆ',
      'ThoughtSpot': 'üåü',
      'Obviously AI': 'ü§î',
      'Xero': 'üíº',
      'QuickBooks': 'üßæ',
      'AdCreative.ai': 'üéØ',
      'Shopify AI': 'üõí',
      'Wix AI': 'üèóÔ∏è',
      'Planner 5D': 'üè†',
      'Autodesk AI': 'üè¢',
      'Fashwell AI': 'üëó',
      'Corti': 'üìû',
      'Viz.ai': 'ü©∫',
    };

    const FALLBACK_ICON = '‚ú®';
    const HIDDEN_CLASS = 'is-hidden';

    const RESOURCE_LINK_LABELS = {
      docs: { ua: '–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—è', en: 'Docs' },
      documentation: { ua: '–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—è', en: 'Documentation' },
      gettingStarted: { ua: '–ü–æ—á–∞—Ç–æ–∫ —Ä–æ–±–æ—Ç–∏', en: 'Getting started' },
      quickstart: { ua: '–®–≤–∏–¥–∫–∏–π —Å—Ç–∞—Ä—Ç', en: 'Quickstart' },
      guide: { ua: '–ì–∞–π–¥', en: 'Guide' },
      handbook: { ua: '–ü–æ—Å—ñ–±–Ω–∏–∫', en: 'Handbook' },
      examples: { ua: '–ü—Ä–∏–∫–ª–∞–¥–∏', en: 'Examples' },
      templates: { ua: '–®–∞–±–ª–æ–Ω–∏', en: 'Templates' },
      repo: { ua: '–†–µ–ø–æ–∑–∏—Ç–æ—Ä—ñ–π', en: 'Repository' },
      repository: { ua: '–†–µ–ø–æ–∑–∏—Ç–æ—Ä—ñ–π', en: 'Repository' },
      sdk: { ua: 'SDK', en: 'SDK' },
      api: { ua: 'API', en: 'API Reference' },
      reference: { ua: '–†–µ—Ñ–µ—Ä–µ–Ω—Å', en: 'Reference' },
      blog: { ua: '–ë–ª–æ–≥', en: 'Blog' },
      updates: { ua: '–û–Ω–æ–≤–ª–µ–Ω–Ω—è', en: 'Updates' },
      changelog: { ua: 'Changelog', en: 'Changelog' },
      roadmap: { ua: '–î–æ—Ä–æ–∂–Ω—è –∫–∞—Ä—Ç–∞', en: 'Roadmap' },
      community: { ua: '–°–ø—ñ–ª—å–Ω–æ—Ç–∞', en: 'Community' },
      forum: { ua: '–§–æ—Ä—É–º', en: 'Forum' },
      support: { ua: '–ü—ñ–¥—Ç—Ä–∏–º–∫–∞', en: 'Support' },
      faq: { ua: 'FAQ', en: 'FAQ' },
      academy: { ua: '–ê–∫–∞–¥–µ–º—ñ—è', en: 'Academy' },
      training: { ua: '–ù–∞–≤—á–∞–Ω–Ω—è', en: 'Training' },
      tutorials: { ua: '–¢—É—Ç–æ—Ä—ñ–∞–ª–∏', en: 'Tutorials' },
      webinar: { ua: '–í–µ–±—ñ–Ω–∞—Ä', en: 'Webinar' },
      events: { ua: '–ü–æ–¥—ñ—ó', en: 'Events' },
      newsletter: { ua: '–†–æ–∑—Å–∏–ª–∫–∞', en: 'Newsletter' },
      youtube: { ua: 'YouTube', en: 'YouTube' },
      demo: { ua: '–î–µ–º–æ', en: 'Demo' },
      playground: { ua: 'Playground', en: 'Playground' },
      showcase: { ua: '–ü—Ä–∏–∫–ª–∞–¥–∏', en: 'Showcase' },
    };

    const RESOURCE_LINK_ORDER = [
      'docs',
      'documentation',
      'gettingStarted',
      'quickstart',
      'guide',
      'handbook',
      'examples',
      'templates',
      'sdk',
      'api',
      'reference',
      'repo',
      'repository',
      'community',
      'forum',
      'support',
      'faq',
      'academy',
      'training',
      'tutorials',
      'webinar',
      'events',
      'blog',
      'updates',
      'changelog',
      'roadmap',
      'newsletter',
      'playground',
      'showcase',
      'youtube',
      'demo',
    ];

    const nodeSizeCache = new Map();

    function ensureResourceMetadata() {
      if (resourcesPromise) {
        return resourcesPromise;
      }
      resourcesPromise = fetch('data/resources.json')
        .then((response) => {
          if (!response.ok) {
            throw new Error(`Failed to load resources metadata: ${response.status} ${response.statusText}`);
          }
          return response.json();
        })
        .then((json) => {
          resourcesByName.clear();
          if (json && Array.isArray(json.services)) {
            json.services.forEach((entry) => {
              if (!entry) return;
              const { name, slug, href } = entry;
              if (name) {
                resourcesByName.set(name, entry);
              }
              if (slug) {
                resourcesByName.set(slug, entry);
              }
              if (href) {
                resourcesByName.set(href, entry);
              }
            });
          }
          resourcesError = null;
          return resourcesByName;
        })
        .catch((error) => {
          resourcesError = error;
          console.warn('Unable to load extended resource metadata', error);
          return resourcesByName;
        });
      return resourcesPromise;
    }

    function getResourceEntry(serviceName) {
      if (!serviceName) return null;
      return resourcesByName.get(serviceName) || null;
    }

    function resolveCustomLabel(labelValue) {
      if (!labelValue) return null;
      if (typeof labelValue === 'string') return labelValue;
      if (typeof labelValue === 'object') {
        const localized = labelValue[lang];
        if (localized) return localized;
        if (labelValue.en) return labelValue.en;
        const fallback = Object.values(labelValue).find((value) => typeof value === 'string' && value.trim().length);
        return fallback || null;
      }
      return null;
    }

    function formatKeyLabel(key) {
      if (!key) return '';
      const entry = RESOURCE_LINK_LABELS[key];
      if (entry) {
        return entry[lang] || entry.en || Object.values(entry)[0] || key;
      }
      const spaced = key
        .replace(/([A-Z])/g, ' $1')
        .replace(/[_-]+/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
      if (!spaced) return key;
      return spaced.charAt(0).toUpperCase() + spaced.slice(1);
    }

    function normalizeResourceLinks(links) {
      if (!links || typeof links !== 'object') return [];
      const items = [];
      const seen = new Set();
      const pushLink = (key, href, label) => {
        if (!href || typeof href !== 'string') return;
        const trimmed = href.trim();
        if (!trimmed) return;
        const fingerprint = `${key}:${trimmed}`;
        if (seen.has(fingerprint)) return;
        seen.add(fingerprint);
        const resolvedLabel = label && label.trim().length ? label : formatKeyLabel(key);
        items.push({ key, href: trimmed, label: resolvedLabel });
      };
      Object.entries(links).forEach(([key, value]) => {
        if (!value) return;
        if (Array.isArray(value)) {
          value.forEach((entry) => {
            if (!entry) return;
            if (typeof entry === 'string') {
              pushLink(key, entry, null);
            } else if (typeof entry === 'object') {
              pushLink(key, entry.href, resolveCustomLabel(entry.label));
            }
          });
        } else if (typeof value === 'object') {
          pushLink(key, value.href, resolveCustomLabel(value.label));
        } else if (typeof value === 'string') {
          pushLink(key, value, null);
        }
      });
      const orderMap = new Map();
      RESOURCE_LINK_ORDER.forEach((key, index) => {
        orderMap.set(key, index);
      });
      items.sort((a, b) => {
        const orderA = orderMap.has(a.key) ? orderMap.get(a.key) : Number.POSITIVE_INFINITY;
        const orderB = orderMap.has(b.key) ? orderMap.get(b.key) : Number.POSITIVE_INFINITY;
        if (orderA !== orderB) {
          return orderA - orderB;
        }
        return a.label.localeCompare(b.label, lang === 'ua' ? 'uk' : 'en', { sensitivity: 'base' });
      });
      return items;
    }

    function updateServiceHighlights(activeKey) {
      serviceNodeRegistry.forEach((entry, key) => {
        if (!entry || !entry.group) return;
        if (key === activeKey) {
          entry.group.classList.add('service-selected');
        } else {
          entry.group.classList.remove('service-selected');
        }
      });
    }

    function showEmptyDetails() {
      if (detailsCardEl) detailsCardEl.classList.add(HIDDEN_CLASS);
      if (detailsEmptyEl) detailsEmptyEl.classList.remove(HIDDEN_CLASS);
      if (detailsPanel) detailsPanel.classList.remove('has-selection');
      if (detailsLinksList) detailsLinksList.innerHTML = '';
      if (detailsTagsList) detailsTagsList.innerHTML = '';
      if (detailsTagsSection) detailsTagsSection.classList.add(HIDDEN_CLASS);
      if (detailsLinksSection) detailsLinksSection.classList.add(HIDDEN_CLASS);
      if (detailsPrimaryLink) detailsPrimaryLink.classList.add(HIDDEN_CLASS);
    }

    function renderServiceDetails(data) {
      if (!data || !detailsPanel || !detailsCardEl || !detailsEmptyEl) {
        showEmptyDetails();
        return;
      }
      if (!resourcesPromise) {
        ensureResourceMetadata();
      }
      const resourceEntry =
        getResourceEntry(data.slug) ||
        getResourceEntry(data.href) ||
        getResourceEntry(data.name);
      if (resourceEntry && selectedServiceData && selectedServiceData.key === data.key) {
        if (resourceEntry.slug && selectedServiceData.slug !== resourceEntry.slug) {
          selectedServiceData.slug = resourceEntry.slug;
        }
      }
      const tags = resourceEntry && Array.isArray(resourceEntry.tags) ? resourceEntry.tags.filter((tag) => typeof tag === 'string' && tag.trim().length) : [];
      const links = resourceEntry && resourceEntry.links ? normalizeResourceLinks(resourceEntry.links) : [];

      detailsEmptyEl.classList.add(HIDDEN_CLASS);
      detailsCardEl.classList.remove(HIDDEN_CLASS);
      detailsPanel.classList.add('has-selection');

      if (detailsTitleEl) detailsTitleEl.textContent = data.name || '';
      if (detailsCategoryEl) {
        const base = data.category || '';
        const groupLabel = data.group || '';
        detailsCategoryEl.textContent = groupLabel ? (base ? `${base} ¬∑ ${groupLabel}` : groupLabel) : base;
      }
      if (detailsDescriptionEl) detailsDescriptionEl.textContent = data.desc || '';

      if (detailsTagsSection && detailsTagsList) {
        detailsTagsList.innerHTML = '';
        if (tags.length) {
          tags.forEach((tag) => {
            const li = document.createElement('li');
            li.textContent = tag;
            detailsTagsList.appendChild(li);
          });
          detailsTagsSection.classList.remove(HIDDEN_CLASS);
        } else {
          detailsTagsSection.classList.add(HIDDEN_CLASS);
        }
      }

      if (detailsLinksSection && detailsLinksList) {
        detailsLinksList.innerHTML = '';
        if (links.length) {
          links.forEach((link) => {
            const anchor = document.createElement('a');
            anchor.className = 'details-link';
            anchor.href = link.href;
            anchor.target = '_blank';
            anchor.rel = 'noreferrer';
            anchor.textContent = link.label;
            const icon = document.createElement('span');
            icon.setAttribute('aria-hidden', 'true');
            icon.textContent = '‚Üó';
            anchor.appendChild(icon);
            detailsLinksList.appendChild(anchor);
          });
          detailsLinksSection.classList.remove(HIDDEN_CLASS);
        } else {
          detailsLinksSection.classList.add(HIDDEN_CLASS);
        }
      }

      if (detailsPrimaryLink) {
        if (data.href) {
          detailsPrimaryLink.href = data.href;
          detailsPrimaryLink.classList.remove(HIDDEN_CLASS);
          const actionLabel = COPY.detailsPrimary[lang];
          detailsPrimaryLink.textContent = actionLabel;
          detailsPrimaryLink.setAttribute('aria-label', `${actionLabel}: ${data.name}`);
          detailsPrimaryLink.setAttribute('title', COPY.detailsPrimaryTitle[lang]);
        } else {
          detailsPrimaryLink.classList.add(HIDDEN_CLASS);
        }
      }
    }

    function selectServiceEntry(serviceKey, entry) {
      if (!entry || !entry.service) {
        return;
      }
      const serviceId = entry.serviceId || makeServiceKey(entry.service);
      if (!serviceId) {
        return;
      }
      const occurrence = typeof entry.occurrence === 'number' ? entry.occurrence : 0;
      const effectiveKey = serviceKey || buildCompositeKey(serviceId, occurrence);
      selectedServiceKey = effectiveKey;
      selectedServiceId = serviceId;
      selectedServiceOccurrence = occurrence;
      selectedServiceData = {
        key: effectiveKey,
        name: entry.service.name || '',
        desc: entry.service.desc || '',
        href: entry.service.href || '',
        category: entry.categoryName || '',
        group: entry.groupName || '',
        slug: serviceId,
        language: entry.language || lang,
      };
      updateServiceHighlights(selectedServiceKey);
      renderServiceDetails(selectedServiceData);
    }

    function clearSelection() {
      selectedServiceKey = null;
      selectedServiceId = null;
      selectedServiceOccurrence = null;
      selectedServiceData = null;
      updateServiceHighlights(null);
      showEmptyDetails();
    }

    function refreshSelectionFromRegistry() {
      const key = selectedServiceKey || (selectedServiceId ? buildCompositeKey(selectedServiceId, selectedServiceOccurrence) : '');
      if (!key) {
        showEmptyDetails();
        return;
      }
      const entry = serviceNodeRegistry.get(key);
      updateServiceHighlights(key);
      if (entry && entry.service) {
        selectedServiceData = {
          key,
          name: entry.service.name || (selectedServiceData && selectedServiceData.name) || '',
          desc: entry.service.desc || (selectedServiceData && selectedServiceData.desc) || '',
          href: entry.service.href || (selectedServiceData && selectedServiceData.href) || '',
          category: entry.categoryName || (selectedServiceData && selectedServiceData.category) || '',
          group: entry.groupName || (selectedServiceData && selectedServiceData.group) || '',
          slug: entry.serviceId || (selectedServiceData && selectedServiceData.slug) || '',
          language: entry.language || lang,
        };
        selectedServiceKey = key;
        selectedServiceId = entry.serviceId || selectedServiceId;
        selectedServiceOccurrence = typeof entry.occurrence === 'number' ? entry.occurrence : selectedServiceOccurrence;
      }
      if (selectedServiceData) {
        renderServiceDetails(selectedServiceData);
      } else {
        showEmptyDetails();
      }
    }

    function formatLabel(name) {
      const icon = ICONS[name] || FALLBACK_ICON;
      return `${icon} ${name}`;
    }

    function slugify(text) {
      if (!text) return '';
      return text
        .toString()
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');
    }

    function makeServiceKey(service) {
      if (!service || !service.name) return '';
      return slugify(service.name);
    }

    function buildCompositeKey(serviceId, occurrence) {
      if (!serviceId) return '';
      const index = typeof occurrence === 'number' ? occurrence : 0;
      return `${serviceId}__${index}`;
    }

    function isGroup(entry) {
      return !!(entry && Array.isArray(entry.items) && entry.items.length);
    }

    function countLeafItems(entries, groupState) {
      if (!Array.isArray(entries)) return 0;
      return entries.reduce((total, entry) => {
        if (!entry) return total;
        if (isGroup(entry)) {
          const items = Array.isArray(entry.items) ? entry.items : [];
          if (groupState && groupState.has(entry.group)) {
            return total + 1 + items.length;
          }
          return total + 1;
        }
        return total + 1;
      }, 0);
    }

    function includesQuery(value, query) {
      return typeof value === 'string' && value.toLowerCase().includes(query);
    }

    function createSearchMeta(cat, query) {
      const entries = Array.isArray(cat.items) ? cat.items : [];
      const branchInfos = entries.map((entry) => {
        if (isGroup(entry)) {
          const items = Array.isArray(entry.items) ? entry.items : [];
          const itemInfos = items.map((svc) => ({
            entry: svc,
            match: includesQuery(svc.name, query) || includesQuery(svc.desc, query),
          }));
          const groupNameMatch = includesQuery(entry.group, query);
          const hasMatch = groupNameMatch || itemInfos.some((info) => info.match);
          return { type: 'group', entry, groupNameMatch, hasMatch, items: itemInfos };
        }
        const match = includesQuery(entry && entry.name, query) || includesQuery(entry && entry.desc, query);
        return { type: 'item', entry, match };
      });
      const catNameMatch = includesQuery(cat.category, query);
      const hasItemMatch = branchInfos.some((branch) => {
        if (branch.type === 'group') return branch.items.some((item) => item.match);
        return branch.match;
      });
      const hasGroupMatch = branchInfos.some((branch) => branch.type === 'group' && branch.groupNameMatch);
      const hasMatch = catNameMatch || branchInfos.some((branch) => (branch.type === 'group' ? branch.hasMatch : branch.match));
      return { hasMatch, catNameMatch, hasItemMatch, hasGroupMatch, branchInfos };
    }

    // State
    let lang = localStorage.getItem('lang') || 'ua';
    let expanded = null; // index of category
    let searchQuery = '';
    let searchTimer = null;
    const expandedGroups = new Map();
    const THEME_STORAGE_KEY = 'theme';
    let theme = localStorage.getItem(THEME_STORAGE_KEY) === 'light' ? 'light' : 'dark';
    let themeColors = {};
    const serviceNodeRegistry = new Map();
    const resourcesByName = new Map();
    let resourcesPromise = null;
    let resourcesError = null;
    let selectedServiceKey = null;
    let selectedServiceId = null;
    let selectedServiceOccurrence = null;
    let selectedServiceData = null;

    function getGroupState(cat, currentLang = lang) {
      const key = `${currentLang}:${cat.category}`;
      let state = expandedGroups.get(key);
      if (!state) {
        state = new Set();
        expandedGroups.set(key, state);
      }
      return state;
    }

    const stage = document.getElementById('stage');
    const uaBtn = document.getElementById('uaBtn');
    const enBtn = document.getElementById('enBtn');
    const searchInput = document.getElementById('searchInput');
    const heroTitleEl = document.getElementById('heroTitle');
    const heroSubtitleEl = document.getElementById('heroSubtitle');
    const heroDescriptionEl = document.getElementById('heroDescription');
    const mapHeadingEl = document.getElementById('mapHeading');
    const bannerTextEl = document.getElementById('bannerText');
    const infoNoteEl = document.getElementById('infoNote');
    const footerRightsEl = document.getElementById('footerRights');
    const footerTaglineEl = document.getElementById('footerTagline');
    const themeButtons = Array.from(document.querySelectorAll('[data-theme-option]'));
    const detailsPanel = document.getElementById('detailsPanel');
    const detailsEmptyEl = document.getElementById('detailsEmpty');
    const detailsEmptyTextEl = document.getElementById('detailsEmptyText');
    const detailsCardEl = document.getElementById('detailsCard');
    const detailsTitleEl = document.getElementById('detailsTitle');
    const detailsCategoryEl = document.getElementById('detailsCategory');
    const detailsDescriptionEl = document.getElementById('detailsDescription');
    const detailsTagsSection = document.getElementById('detailsTagsSection');
    const detailsTagsLabel = document.getElementById('detailsTagsLabel');
    const detailsTagsList = document.getElementById('detailsTagsList');
    const detailsLinksSection = document.getElementById('detailsLinksSection');
    const detailsLinksLabel = document.getElementById('detailsLinksLabel');
    const detailsLinksList = document.getElementById('detailsLinksList');
    const detailsPrimaryLink = document.getElementById('detailsPrimaryLink');
    const detailsCloseBtn = document.getElementById('detailsCloseBtn');

    const COPY = {
      heroTitle: {
        ua: '–í–∞—à –∫–æ–º–ø–∞—Å —É —Å–≤—ñ—Ç—ñ –®–Ü —Å–µ—Ä–≤—ñ—Å—ñ–≤',
        en: 'Your compass through the AI service landscape',
      },
      heroSubtitle: {
        ua: '–í—ñ–¥–∫—Ä–∏–≤–∞–π—Ç–µ –ø–µ—Ä–µ–≤—ñ—Ä–µ–Ω—ñ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏ –¥–ª—è –±—ñ–∑–Ω–µ—Å—É, —Ç–≤–æ—Ä—á–æ—Å—Ç—ñ –π –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü—ñ—ó.',
        en: 'Discover trusted platforms for business, creativity, and automation.',
      },
      heroDescription: {
        ua: '–ü–µ—Ä–µ–º–∏–∫–∞–π—Ç–µ –º–æ–≤—É, –æ–±–∏—Ä–∞–π—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é —Ç–∞ –≤—ñ–¥–∫—Ä–∏–≤–∞–π—Ç–µ –∫–∞—Ä—Ç–∫–∏ —Å–µ—Ä–≤—ñ—Å—ñ–≤ —ñ–∑ –æ–ø–∏—Å–æ–º, –ø–æ—Å–∏–ª–∞–Ω–Ω—è–º–∏ –π –∫–æ—Ä–∏—Å–Ω–∏–º–∏ –º–∞—Ç–µ—Ä—ñ–∞–ª–∞–º–∏.',
        en: 'Switch languages, explore categories, and open service cards to review descriptions, links, and helpful resources.',
      },
      mapHeading: {
        ua: '–ú–∞–ø–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ–π AI‚Äë—Å–µ—Ä–≤—ñ—Å—ñ–≤',
        en: 'Map of AI service categories',
      },
      banner: {
        ua: '–ë—ñ–±–ª—ñ–æ—Ç–µ–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–µ–Ω–∏—Ö AI —Å–µ—Ä–≤—ñ—Å—ñ–≤ –¥–ª—è –º–∞—Ä–∫–µ—Ç–∏–Ω–≥—É, –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü—ñ—ó —Ç–∞ –∞–Ω–∞–ª—ñ—Ç–∏–∫–∏.',
        en: 'Curated AI tools for marketing, automation, and analytics teams.',
      },
      searchPlaceholder: {
        ua: '–ü–æ—à—É–∫ —Å–µ—Ä–≤—ñ—Å—ñ–≤‚Ä¶',
        en: 'Search services‚Ä¶',
      },
      searchAria: {
        ua: '–ü–æ—à—É–∫ —Å–µ—Ä–≤—ñ—Å—ñ–≤ –Ω–∞ –º–∞–ø—ñ',
        en: 'Search services on the map',
      },
      noResults: {
        ua: '–ù–µ–º–∞—î —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ –∑–∞ –∑–∞–ø–∏—Ç–æ–º',
        en: 'No results for this query',
      },
      infoNote: {
        ua: '–ö–ª—ñ–∫–Ω—ñ—Ç—å –∫–∞—Ç–µ–≥–æ—Ä—ñ—é, —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏ —Å–µ—Ä–≤—ñ—Å–∏. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –Ω–∞ –≤—É–∑–æ–ª ‚Äî –≤—ñ–¥–∫—Ä–∏—î—Ç—å—Å—è –∫–∞—Ä—Ç–∫–∞ –∑ –æ–ø–∏—Å–æ–º —ñ –¥–æ–±—ñ—Ä–∫–æ—é –ø–æ—Å–∏–ª–∞–Ω—å. –ù–∞–≤–µ–¥—ñ—Ç—å, —â–æ–± –ø—ñ–¥—Å–≤—ñ—Ç–∏—Ç–∏.',
        en: 'Click a category to reveal services. Select any node to open a detail card with the description and curated links. Hover to highlight.',
      },
      footerRights: {
        ua: '–£—Å—ñ –ø—Ä–∞–≤–∞ –∑–∞—Ö–∏—â–µ–Ω—ñ ¬∑ 2024',
        en: 'All rights reserved ¬∑ 2024',
      },
      footerTagline: {
        ua: '–°—Ç–≤–æ—Ä–µ–Ω–æ, —â–æ–± –¥–æ–ø–æ–º–æ–≥—Ç–∏ –¥–æ—Å–ª—ñ–¥–∂—É–≤–∞—Ç–∏ –π –ø–æ—Ä—ñ–≤–Ω—é–≤–∞—Ç–∏ AI-—Ä—ñ—à–µ–Ω–Ω—è –≤–ø–µ–≤–Ω–µ–Ω–æ.',
        en: 'Crafted to help you explore and compare AI solutions with confidence.',
      },
      themeDark: {
        ua: '–¢–µ–º–Ω–∞',
        en: 'Dark',
      },
      themeLight: {
        ua: '–°–≤—ñ—Ç–ª–∞',
        en: 'Light',
      },
      loading: {
        ua: '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è‚Ä¶',
        en: 'Loading‚Ä¶',
      },
      loadError: {
        ua: '–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –¥–∞–Ω—ñ',
        en: 'Failed to load data',
      },
      detailsRegion: {
        ua: '–ö–∞—Ä—Ç–∫–∞ –≤–∏–±—Ä–∞–Ω–æ–≥–æ —Å–µ—Ä–≤—ñ—Å—É',
        en: 'Selected service details',
      },
      detailsEmpty: {
        ua: '–û–±–µ—Ä—ñ—Ç—å —Å–µ—Ä–≤—ñ—Å –Ω–∞ –º–∞–ø—ñ, —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏ –æ–ø–∏—Å —ñ –∫–æ—Ä–∏—Å–Ω—ñ –º–∞—Ç–µ—Ä—ñ–∞–ª–∏.',
        en: 'Pick a service on the map to see its description and helpful resources.',
      },
      detailsPrimary: {
        ua: '–í—ñ–¥–∫—Ä–∏—Ç–∏ —Å–∞–π—Ç',
        en: 'Open website',
      },
      detailsPrimaryTitle: {
        ua: '–í—ñ–¥–∫—Ä–∏—Ç–∏ —Å–∞–π—Ç —Å–µ—Ä–≤—ñ—Å—É –≤ –Ω–æ–≤—ñ–π –≤–∫–ª–∞–¥—Ü—ñ',
        en: 'Open the service website in a new tab',
      },
      detailsTagsLabel: {
        ua: '–¢–µ–≥–∏',
        en: 'Tags',
      },
      detailsLinksLabel: {
        ua: '–ö–æ—Ä–∏—Å–Ω—ñ –ø–æ—Å–∏–ª–∞–Ω–Ω—è',
        en: 'Helpful links',
      },
      detailsClose: {
        ua: '–ó–∞–∫—Ä–∏—Ç–∏ –∫–∞—Ä—Ç–∫—É',
        en: 'Close card',
      },
    };

    function applyCopy() {
      if (bannerTextEl) bannerTextEl.textContent = COPY.banner[lang];
      if (heroTitleEl) heroTitleEl.textContent = COPY.heroTitle[lang];
      if (heroSubtitleEl) heroSubtitleEl.textContent = COPY.heroSubtitle[lang];
      if (heroDescriptionEl) heroDescriptionEl.textContent = COPY.heroDescription[lang];
      if (mapHeadingEl) mapHeadingEl.textContent = COPY.mapHeading[lang];
      if (searchInput) {
        searchInput.placeholder = COPY.searchPlaceholder[lang];
        searchInput.setAttribute('aria-label', COPY.searchAria[lang]);
      }
      if (infoNoteEl) infoNoteEl.textContent = COPY.infoNote[lang];
      if (footerRightsEl) footerRightsEl.textContent = COPY.footerRights[lang];
      if (footerTaglineEl) footerTaglineEl.textContent = COPY.footerTagline[lang];
      if (detailsPanel) detailsPanel.setAttribute('aria-label', COPY.detailsRegion[lang]);
      if (detailsEmptyTextEl) detailsEmptyTextEl.textContent = COPY.detailsEmpty[lang];
      if (detailsTagsLabel) detailsTagsLabel.textContent = COPY.detailsTagsLabel[lang];
      if (detailsLinksLabel) detailsLinksLabel.textContent = COPY.detailsLinksLabel[lang];
      if (detailsPrimaryLink) {
        detailsPrimaryLink.textContent = COPY.detailsPrimary[lang];
        detailsPrimaryLink.setAttribute('title', COPY.detailsPrimaryTitle[lang]);
      }
      if (detailsCloseBtn) {
        const label = COPY.detailsClose[lang];
        detailsCloseBtn.setAttribute('aria-label', label);
        detailsCloseBtn.setAttribute('title', label);
      }
      const themeSuffix = lang === 'ua' ? '—Ç–µ–º–∞' : 'theme';
      themeButtons.forEach((btn) => {
        if (!btn) return;
        const option = btn.dataset.themeOption;
        if (option === 'dark') {
          const label = COPY.themeDark[lang];
          const text = `üåô ${label}`;
          const fullLabel = `${label} ${themeSuffix}`;
          btn.textContent = text;
          btn.setAttribute('aria-label', fullLabel);
          btn.setAttribute('title', fullLabel);
        } else if (option === 'light') {
          const label = COPY.themeLight[lang];
          const text = `‚òÄÔ∏è ${label}`;
          const fullLabel = `${label} ${themeSuffix}`;
          btn.textContent = text;
          btn.setAttribute('aria-label', fullLabel);
          btn.setAttribute('title', fullLabel);
        }
      });
      document.documentElement.lang = lang === 'ua' ? 'uk' : 'en';
    }

    function readThemeColors() {
      const styles = getComputedStyle(document.body);
      return {
        surface: styles.getPropertyValue('--surface-color').trim() || '#fff',
        surfaceBorder: styles.getPropertyValue('--surface-border').trim() || '#d1d5db',
        nodeText: styles.getPropertyValue('--node-text').trim() || '#111827',
        errorText: styles.getPropertyValue('--error-text').trim() || '#b91c1c',
        tooltipBg: styles.getPropertyValue('--tooltip-bg').trim() || '#111827',
        tooltipText: styles.getPropertyValue('--tooltip-text').trim() || '#fff',
      };
    }

    function updateThemeToggleState(activeTheme) {
      themeButtons.forEach((btn) => {
        if (!btn) return;
        const isActive = btn.dataset.themeOption === activeTheme;
        btn.classList.toggle('active', isActive);
        btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      });
    }

    function applyThemeAttributes(nextTheme) {
      const normalized = nextTheme === 'light' ? 'light' : 'dark';
      document.body.setAttribute('data-theme', normalized);
      updateThemeToggleState(normalized);
      themeColors = readThemeColors();
    }

    function changeTheme(nextTheme) {
      const normalized = nextTheme === 'light' ? 'light' : 'dark';
      if (normalized === theme) {
        updateThemeToggleState(normalized);
        return;
      }
      theme = normalized;
      localStorage.setItem(THEME_STORAGE_KEY, normalized);
      applyThemeAttributes(normalized);
      render().catch((error) => {
        console.error('Failed to render dataset after theme change', error);
      });
    }

    themeButtons.forEach((btn) => {
      if (!btn) return;
      btn.addEventListener('click', () => {
        const option = btn.dataset.themeOption;
        if (option) {
          changeTheme(option);
        }
      });
    });

    if (detailsCloseBtn) {
      detailsCloseBtn.addEventListener('click', () => {
        clearSelection();
        detailsCloseBtn.blur();
      });
    }

    document.addEventListener('keydown', (evt) => {
      if (evt.key === 'Escape' && selectedServiceKey) {
        clearSelection();
      }
    });

    if (stage) {
      stage.addEventListener('click', (evt) => {
        if (evt.target === stage && selectedServiceKey) {
          clearSelection();
        }
      });
    }

    async function setLang(l) {
      lang = l;
      localStorage.setItem('lang', l);
      uaBtn.classList.toggle('active', l==='ua');
      enBtn.classList.toggle('active', l==='en');
      expanded = null;
      expandedGroups.clear();
      nodeSizeCache.clear();
      applyCopy();
      if (searchInput) {
        searchInput.value = searchQuery;
      }
      await render();
    }

    uaBtn.onclick = () => {
      setLang('ua').catch((error) => {
        console.error('Failed to switch to Ukrainian dataset', error);
      });
    };
    enBtn.onclick = () => {
      setLang('en').catch((error) => {
        console.error('Failed to switch to English dataset', error);
      });
    };

    if (searchInput) {
      searchInput.value = searchQuery;
      const commitSearch = () => {
        searchQuery = searchInput.value;
        render().catch((error) => {
          console.error('Failed to render dataset after search update', error);
        });
      };
      const scheduleSearch = () => {
        if (searchTimer) {
          clearTimeout(searchTimer);
        }
        searchTimer = setTimeout(commitSearch, 180);
      };
      searchInput.addEventListener('input', scheduleSearch);
      searchInput.addEventListener('search', scheduleSearch);
    }

    // Drawing primitives
    function group(parent) {
      const el = document.createElementNS('http://www.w3.org/2000/svg','g');
      parent.appendChild(el);
      return el;
    }
    function path(parent, d, opts={}) {
      const el = document.createElementNS('http://www.w3.org/2000/svg','path');
      el.setAttribute('d', d);
      el.setAttribute('fill', opts.fill || 'none');
      if (opts.stroke) el.setAttribute('stroke', opts.stroke);
      if (opts.sw) el.setAttribute('stroke-width', opts.sw);
      if (opts.op) el.setAttribute('stroke-opacity', opts.op);
      if (opts.sd) el.setAttribute('stroke-dasharray', opts.sd);
      parent.appendChild(el);
      return el;
    }
    function createNode(parent, x, y, label, opts={}) {
      const g = group(parent);
      g.setAttribute('transform', `translate(${x},${y})`);
      const textEl = document.createElementNS('http://www.w3.org/2000/svg','text');
      textEl.setAttribute('text-anchor','middle');
      textEl.setAttribute('dominant-baseline','middle');
      textEl.setAttribute('class', opts.cls || 'normal');
      textEl.textContent = label;
      g.appendChild(textEl);
      const padX = opts.padX ?? 18;
      const padY = opts.padY ?? 12;
      const classKey = opts.cls || 'normal';
      const cachedByLabel = nodeSizeCache.get(label);
      let width;
      let height;
      if (cachedByLabel && cachedByLabel.has(classKey)) {
        const cachedSize = cachedByLabel.get(classKey);
        width = cachedSize.width;
        height = cachedSize.height;
      } else {
        const bbox = textEl.getBBox();
        width = bbox.width;
        height = bbox.height;
        let entry = cachedByLabel;
        if (!entry) {
          entry = new Map();
          nodeSizeCache.set(label, entry);
        }
        entry.set(classKey, { width, height });
      }
      const rx = width / 2 + padX;
      const ry = height / 2 + padY;
      const ell = document.createElementNS('http://www.w3.org/2000/svg','ellipse');
      ell.setAttribute('cx', 0);
      ell.setAttribute('cy', 0);
      ell.setAttribute('rx', rx);
      ell.setAttribute('ry', ry);
      ell.setAttribute('fill', opts.fill || '#fff');
      if (opts.fillOpacity != null) ell.setAttribute('fill-opacity', opts.fillOpacity);
      if (opts.stroke) ell.setAttribute('stroke', opts.stroke);
      if (opts.sw) ell.setAttribute('stroke-width', opts.sw);
      if (opts.op) ell.setAttribute('opacity', opts.op);
      g.insertBefore(ell, textEl);
      return { group: g, text: textEl, ellipse: ell, rx, ry, x, y };
    }

    // Tooltip management
    let tipGroup = null;
    let measureTextEl = null;

    function wrapText(text, maxWidth) {
      const lines = [];
      if (!text) return lines;
      if (!measureTextEl) {
        measureTextEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        measureTextEl.setAttribute('class', 'muted');
        measureTextEl.setAttribute('visibility', 'hidden');
      }
      if (measureTextEl.parentNode !== stage) {
        stage.appendChild(measureTextEl);
      }
      const words = text.split(/\s+/);
      let current = '';
      words.forEach((word) => {
        const candidate = current ? `${current} ${word}` : word;
        measureTextEl.textContent = candidate;
        if (measureTextEl.getComputedTextLength() <= maxWidth) {
          current = candidate;
        } else {
          if (current) {
            lines.push(current);
            current = '';
          }
          measureTextEl.textContent = word;
          if (measureTextEl.getComputedTextLength() > maxWidth) {
            lines.push(word);
            current = '';
          } else {
            current = word;
          }
        }
      });
      if (current) lines.push(current);
      return lines;
    }

    function showTip(x, y, title, desc, href) {
      hideTip();
      const palette = themeColors.surface ? themeColors : readThemeColors();
      tipGroup = group(stage);
      tipGroup.setAttribute('class','tip');
      const w = 340;
      const pad = 14;
      const maxWidth = w - pad * 2;
      const lines = wrapText(desc, maxWidth);
      const lineHeight = 18;
      const descHeight = Math.max(lineHeight, lines.length * lineHeight);
      const titleHeight = 18;
      const linkHeight = 16;
      const gap = 12;
      const h = Math.max(170, pad + titleHeight + gap + descHeight + gap + linkHeight + pad);
      const vb = (stage.getAttribute('viewBox') || '0 0 1100 760').split(' ').map(Number);
      const viewW = vb[2] || 1100;
      const viewH = vb[3] || 760;
      let tx = x + 18;
      let ty = y - h - 14;
      if (tx + w > viewW - 12) tx = x - w - 18;
      if (tx < 12) tx = 12;
      if (ty < 12) ty = y + 18;
      if (ty + h > viewH - 12) ty = Math.max(12, viewH - h - 12);
      const bg = document.createElementNS('http://www.w3.org/2000/svg','rect');
      bg.setAttribute('x', tx); bg.setAttribute('y', ty); bg.setAttribute('rx', 12); bg.setAttribute('ry', 12);
      bg.setAttribute('width', w); bg.setAttribute('height', h);
      bg.setAttribute('fill', palette.tooltipBg || '#111827'); bg.setAttribute('opacity', '0.95');
      tipGroup.appendChild(bg);
      const t1 = document.createElementNS('http://www.w3.org/2000/svg','text');
      t1.setAttribute('x', tx + pad); t1.setAttribute('y', ty + pad + 6); t1.setAttribute('fill', palette.tooltipText || '#fff');
      t1.setAttribute('style','font-weight:700; font-size:13px;');
      t1.textContent = title;
      tipGroup.appendChild(t1);
      const t2 = document.createElementNS('http://www.w3.org/2000/svg','text');
      t2.setAttribute('x', tx + pad);
      t2.setAttribute('y', ty + pad + titleHeight + 4);
      t2.setAttribute('class', 'muted');
      t2.setAttribute('dominant-baseline', 'hanging');
      lines.forEach((line, idx) => {
        const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
        tspan.setAttribute('x', tx + pad);
        tspan.setAttribute('dy', idx === 0 ? 0 : lineHeight);
        tspan.textContent = line;
        t2.appendChild(tspan);
      });
      tipGroup.appendChild(t2);
      const link = document.createElementNS('http://www.w3.org/2000/svg','a');
      link.setAttribute('href', href); link.setAttribute('target','_blank'); link.setAttribute('rel','noreferrer');
      const t3 = document.createElementNS('http://www.w3.org/2000/svg','text');
      t3.setAttribute('x', tx + pad);
      t3.setAttribute('y', ty + h - pad);
      t3.setAttribute('class','link');
      t3.textContent = (lang==='ua' ? '–í—ñ–¥–∫—Ä–∏—Ç–∏ —Å–∞–π—Ç ‚Üí' : 'Visit site ‚Üí');
      link.appendChild(t3);
      tipGroup.appendChild(link);
    }
    function hideTip() {
      if (tipGroup) {
        if (tipGroup.parentNode) tipGroup.parentNode.removeChild(tipGroup);
        tipGroup = null;
      }
    }

    async function render() {
      const activeLang = lang;
      const palette = themeColors.surface ? themeColors : readThemeColors();
      hideTip();
      serviceNodeRegistry.clear();
      const serviceOccurrences = new Map();
      const hadMeasureText = measureTextEl && measureTextEl.parentNode === stage;
      stage.innerHTML = '';

      if (hadMeasureText) {
        stage.appendChild(measureTextEl);
      }

      if (!datasetCache.has(activeLang)) {
        stage.setAttribute('viewBox', '0 0 400 200');
        stage.setAttribute('height', 200);
        stage.style.height = '200px';
        const loadingLayer = group(stage);
        const loadingNode = createNode(loadingLayer, 200, 100, COPY.loading[activeLang], {
          fill: palette.surface,
          stroke: palette.surfaceBorder,
          sw: 1.6,
          padX: 24,
          padY: 16,
          cls: 'normal',
        });
        loadingNode.text.setAttribute('fill', palette.nodeText);
      }

      let data;
      try {
        data = await loadDataset(activeLang);
      } catch (error) {
        stage.innerHTML = '';
        if (hadMeasureText) {
          stage.appendChild(measureTextEl);
        }
        stage.setAttribute('viewBox', '0 0 400 200');
        stage.setAttribute('height', 200);
        stage.style.height = '200px';
        const errorLayer = group(stage);
        const errorNode = createNode(errorLayer, 200, 100, COPY.loadError[activeLang], {
          fill: palette.surface,
          stroke: palette.errorText,
          sw: 1.6,
          padX: 24,
          padY: 16,
          cls: 'normal',
        });
        errorNode.text.setAttribute('fill', palette.errorText);
        console.error('Failed to load dataset', error);
        return;
      }

      if (activeLang !== lang) {
        return;
      }

      stage.innerHTML = '';
      if (hadMeasureText) {
        stage.appendChild(measureTextEl);
      }

      const connectorsLayer = group(stage);
      const nodesLayer = group(stage);

      if (!Array.isArray(data)) {
        data = [];
      }
      const CATEGORY_GAP = 240;
      const ITEM_GAP = 250;
      const GROUP_GAP = 170;
      const BASE_SPACING = 110;
      const ITEM_SPACING = 64;
      const MARGIN_Y = 120;
      const CANVAS_WIDTH = 1200;
      const MIN_HEIGHT = 680;

      const query = (searchQuery || '').trim().toLowerCase();
      const searchActive = query.length > 0;
      const searchMeta = searchActive ? data.map((cat) => createSearchMeta(cat, query)) : [];
      const visibleIndices = [];

      data.forEach((cat, idx) => {
        if (!searchActive) {
          visibleIndices.push(idx);
        } else if (searchMeta[idx] && searchMeta[idx].hasMatch) {
          visibleIndices.push(idx);
        }
      });

      if (searchActive && visibleIndices.length === 0) {
        const height = MIN_HEIGHT;
        stage.setAttribute('viewBox', `0 0 ${CANVAS_WIDTH} ${height}`);
        stage.setAttribute('height', height);
        stage.style.height = `${height}px`;
        const message = createNode(nodesLayer, CANVAS_WIDTH / 2, height / 2, COPY.noResults[activeLang], {
          fill: palette.surface,
          stroke: palette.surfaceBorder,
          sw: 1.6,
          padX: 28,
          padY: 18,
          cls: 'normal',
        });
        message.text.setAttribute('fill', palette.nodeText);
        return;
      }

      const total = visibleIndices.length;
      const rightCount = Math.ceil(total / 2);
      const leftCount = total - rightCount;

      const weights = visibleIndices.map((idx) => {
        if (searchActive) {
          const meta = searchMeta[idx];
          if (!meta) return 1.4;
          const entries = Array.isArray(data[idx].items) ? data[idx].items : [];
          let visibleCount = 0;
          entries.forEach((entry, entryIdx) => {
            if (isGroup(entry)) {
              const branchMeta = meta.branchInfos ? meta.branchInfos[entryIdx] : null;
              if (!branchMeta || !branchMeta.hasMatch) return;
              visibleCount += 1;
              const matchedItems = branchMeta.items.filter((info) => info.match);
              visibleCount += matchedItems.length;
            } else if (entry && entry.name) {
              const branchMeta = meta.branchInfos ? meta.branchInfos[entryIdx] : null;
              if (branchMeta && branchMeta.match) {
                visibleCount += 1;
              }
            }
          });
          return Math.max(1.6, visibleCount ? visibleCount * 0.9 : 1.4);
        }
        if (expanded === idx) {
          const groupState = getGroupState(data[idx], activeLang);
          const leafCount = countLeafItems(data[idx].items, groupState);
          return Math.max(1.6, leafCount * 0.9);
        }
        return 1;
      });

      const sum = (arr) => arr.reduce((acc, val) => acc + val, 0);
      const rightWeight = sum(weights.slice(0, rightCount));
      const leftWeight = sum(weights.slice(rightCount));
      const span = (weight, count) => (weight > 0 ? weight : Math.max(count, 1));

      const height = Math.max(
        MIN_HEIGHT,
        MARGIN_Y * 2 + span(rightWeight, rightCount) * BASE_SPACING,
        MARGIN_Y * 2 + span(leftWeight, leftCount) * BASE_SPACING
      );
      const availableHeight = height - MARGIN_Y * 2;

      stage.setAttribute('viewBox', `0 0 ${CANVAS_WIDTH} ${height}`);
      stage.setAttribute('height', height);
      stage.style.height = `${height}px`;

      const rootX = CANVAS_WIDTH / 2;
      const rootY = height / 2;

      const positions = new Map();
      const layoutSide = (subset, subsetWeights, side) => {
        if (!subset.length) return;
        const totalWeight = subsetWeights.reduce((acc, val) => acc + val, 0) || subset.length;
        let cursor = MARGIN_Y;
        subset.forEach((idx, order) => {
          const weight = subsetWeights[order] || totalWeight / subset.length;
          const portion = weight / totalWeight;
          const segment = portion * availableHeight;
          const centerY = cursor + segment / 2;
          positions.set(idx, {
            x: side === 'right' ? rootX + CATEGORY_GAP : rootX - CATEGORY_GAP,
            y: centerY,
            side,
          });
          cursor += segment;
        });
      };

      layoutSide(visibleIndices.slice(0, rightCount), weights.slice(0, rightCount), 'right');
      layoutSide(visibleIndices.slice(rightCount), weights.slice(rightCount), 'left');

      const rootLabel = 'AI Compass';
      const rootNode = createNode(nodesLayer, rootX, rootY, rootLabel, {
        fill: palette.surface,
        stroke: palette.nodeText,
        sw: 2,
        padX: 30,
        padY: 20,
        cls: 'large',
      });

      const catNodes = new Array(data.length);
      visibleIndices.forEach((idx) => {
        const pos = positions.get(idx);
        if (!pos) return;
        const cat = data[idx];
        const node = createNode(nodesLayer, pos.x, pos.y, cat.category, {
          fill: cat.color,
          fillOpacity: 0.12,
          stroke: cat.color,
          sw: 2,
          padX: 26,
          padY: 16,
          cls: 'normal',
        });
        if (!searchActive) {
          node.group.style.cursor = 'pointer';
          node.group.setAttribute('role', 'button');
          node.group.setAttribute('tabindex', '0');
          node.group.setAttribute('aria-label', cat.category);
          node.group.addEventListener('click', () => {
            expanded = expanded === idx ? null : idx;
            render().catch((error) => {
              console.error('Failed to render dataset after category toggle', error);
            });
          });
          node.group.addEventListener('keypress', (evt) => {
            if (evt.key === 'Enter' || evt.key === ' ') {
              evt.preventDefault();
              expanded = expanded === idx ? null : idx;
              render().catch((error) => {
                console.error('Failed to render dataset after keyboard toggle', error);
              });
            }
          });
        } else {
          node.group.setAttribute('aria-label', cat.category);
          if (searchMeta[idx] && (searchMeta[idx].catNameMatch || searchMeta[idx].hasItemMatch || searchMeta[idx].hasGroupMatch)) {
            node.group.classList.add('search-hit');
          }
        }
        catNodes[idx] = { ...node, pos, cat };
      });

      const rootBranches = group(connectorsLayer);
      visibleIndices.forEach((idx) => {
        const node = catNodes[idx];
        if (!node) return;
        const { pos, cat } = node;
        const startX = pos.side === 'right' ? rootNode.x + rootNode.rx : rootNode.x - rootNode.rx;
        const startY = rootNode.y;
        const endX = pos.side === 'right' ? pos.x - node.rx : pos.x + node.rx;
        const endY = pos.y;
        const ctrlX = startX + (endX - startX) * 0.5;
        path(
          rootBranches,
          `M ${startX} ${startY} C ${ctrlX} ${startY}, ${ctrlX} ${endY}, ${endX} ${endY}`,
          { stroke: cat.color, sw: 2, op: 0.45 }
        );
      });

      const highlightLayer = group(connectorsLayer);

      visibleIndices.forEach((idx) => {
        const node = catNodes[idx];
        if (!node) return;
        const { cat, pos } = node;
        const meta = searchActive ? searchMeta[idx] : null;
        const shouldExpand = searchActive ? !!(meta && (meta.hasItemMatch || meta.hasGroupMatch)) : expanded === idx;
        if (!shouldExpand) return;

        const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
        highlight.setAttribute('cx', node.x);
        highlight.setAttribute('cy', node.y);
        highlight.setAttribute('rx', node.rx + 28);
        highlight.setAttribute('ry', node.ry + 24);
        highlight.setAttribute('fill', 'none');
        highlight.setAttribute('stroke', cat.color);
        highlight.setAttribute('stroke-opacity', '0.55');
        highlight.setAttribute('stroke-dasharray', '8 12');
        highlightLayer.appendChild(highlight);

        const entries = Array.isArray(cat.items) ? cat.items : [];
        const groupState = searchActive ? null : getGroupState(cat, activeLang);
        const branches = [];

        entries.forEach((entry, entryIdx) => {
          if (isGroup(entry)) {
            const items = Array.isArray(entry.items) ? entry.items : [];
            if (searchActive) {
              const branchMeta = meta && meta.branchInfos ? meta.branchInfos[entryIdx] : null;
              if (!branchMeta || !branchMeta.hasMatch) return;
              const matchedItems = branchMeta.items.filter((info) => info.match).map((info) => info.entry);
              branches.push({
                type: 'group',
                entry,
                items: matchedItems,
                expanded: true,
                slots: 1 + matchedItems.length,
                meta: branchMeta,
              });
            } else {
              const expandedGroup = groupState.has(entry.group);
              branches.push({
                type: 'group',
                entry,
                items,
                expanded: expandedGroup,
                slots: expandedGroup ? 1 + items.length : 1,
              });
            }
          } else if (entry && entry.name) {
            if (searchActive) {
              const branchMeta = meta && meta.branchInfos ? meta.branchInfos[entryIdx] : null;
              if (!branchMeta || !branchMeta.match) return;
              branches.push({ type: 'item', entry, slots: 1, highlight: true });
            } else {
              branches.push({ type: 'item', entry, slots: 1 });
            }
          }
        });

        const totalSlots = branches.reduce((sumSlots, branch) => sumSlots + branch.slots, 0);
        if (!totalSlots) return;

        const branchHeight = ITEM_SPACING * Math.max(0, totalSlots - 1);
        const startY = node.y - branchHeight / 2;
        const branchConnectors = group(connectorsLayer);
        const nestedConnectors = group(connectorsLayer);
        const groupLayer = group(nodesLayer);
        const leafLayer = group(nodesLayer);

        let slotCursor = 0;
        branches.forEach((branch) => {
          if (branch.type === 'group') {
            const groupX = pos.side === 'right' ? pos.x + GROUP_GAP : pos.x - GROUP_GAP;
            const groupY = startY + slotCursor * ITEM_SPACING;
            const hasItems = branch.items.length > 0;
            const indicator = searchActive ? (hasItems ? '‚ñæ' : '‚Ä¢') : branch.expanded ? '‚ñæ' : '‚ñ∏';
            const labelText = branch.entry.group ? `${indicator} ${branch.entry.group}` : indicator;
            const groupNode = createNode(groupLayer, groupX, groupY, labelText, {
              fill: palette.surface,
              stroke: cat.color,
              sw: 1.6,
              padX: 20,
              padY: 12,
              cls: 'small',
            });
            if (!searchActive) {
              groupNode.group.style.cursor = 'pointer';
              groupNode.group.setAttribute('role', 'button');
              groupNode.group.setAttribute('tabindex', '0');
              groupNode.group.setAttribute('aria-label', branch.entry.group);
              groupNode.group.setAttribute('aria-expanded', branch.expanded ? 'true' : 'false');
              const toggleGroup = () => {
                if (groupState.has(branch.entry.group)) {
                  groupState.delete(branch.entry.group);
                } else {
                  groupState.add(branch.entry.group);
                }
                render().catch((error) => {
                  console.error('Failed to render dataset after group toggle', error);
                });
              };
              groupNode.group.addEventListener('click', toggleGroup);
              groupNode.group.addEventListener('keypress', (evt) => {
                if (evt.key === 'Enter' || evt.key === ' ') {
                  evt.preventDefault();
                  toggleGroup();
                }
              });
            } else if (branch.meta && (branch.meta.groupNameMatch || branch.items.length)) {
              groupNode.group.classList.add('search-hit');
            }

            const startBranchX = pos.side === 'right' ? node.x + node.rx : node.x - node.rx;
            const endBranchX = pos.side === 'right' ? groupX - groupNode.rx : groupX + groupNode.rx;
            const ctrlBranchX = startBranchX + (endBranchX - startBranchX) * 0.6;
            path(
              branchConnectors,
              `M ${startBranchX} ${node.y} C ${ctrlBranchX} ${node.y}, ${ctrlBranchX} ${groupY}, ${endBranchX} ${groupY}`,
              { stroke: cat.color, sw: 1.6, op: 0.6 }
            );

            const itemsToRender = searchActive ? branch.items : branch.expanded ? branch.items : [];
            itemsToRender.forEach((svc, svcIdx) => {
              const slotIndex = slotCursor + 1 + svcIdx;
              const itemY = startY + slotIndex * ITEM_SPACING;
              const itemX = pos.side === 'right' ? pos.x + ITEM_GAP : pos.x - ITEM_GAP;
              const label = formatLabel(svc.name);
              const itemNode = createNode(leafLayer, itemX, itemY, label, {
                fill: palette.surface,
                stroke: cat.color,
                sw: 1.5,
                padX: 20,
                padY: 12,
                cls: 'small',
              });
              if (searchActive) {
                itemNode.group.classList.add('search-hit');
              }
              const serviceId = makeServiceKey(svc);
              const occurrence = serviceOccurrences.get(serviceId) || 0;
              serviceOccurrences.set(serviceId, occurrence + 1);
              const serviceKey = buildCompositeKey(serviceId, occurrence);
              const registryEntry = {
                group: itemNode.group,
                service: svc,
                categoryName: cat.category,
                groupName: branch.entry && branch.entry.group ? branch.entry.group : '',
                language: activeLang,
                serviceId,
                occurrence,
              };
              if (serviceKey) {
                serviceNodeRegistry.set(serviceKey, registryEntry);
                itemNode.group.dataset.serviceKey = serviceKey;
              }
              itemNode.group.classList.add('service-node');
              itemNode.group.style.cursor = 'pointer';
              itemNode.group.setAttribute('aria-label', svc.name);
              itemNode.group.setAttribute('role', 'button');
              itemNode.group.setAttribute('tabindex', '0');
              const toggleHover = (state) => {
                if (state) {
                  itemNode.group.classList.add('service-hover');
                } else {
                  itemNode.group.classList.remove('service-hover');
                }
              };
              itemNode.group.addEventListener('mouseenter', () => toggleHover(true));
              itemNode.group.addEventListener('mouseleave', () => toggleHover(false));
              itemNode.group.addEventListener('focus', () => toggleHover(true));
              itemNode.group.addEventListener('blur', () => toggleHover(false));
              const handleSelect = () => {
                selectServiceEntry(serviceKey, registryEntry);
              };
              itemNode.group.addEventListener('click', (evt) => {
                evt.preventDefault();
                evt.stopPropagation();
                handleSelect();
              });
              itemNode.group.addEventListener('keypress', (evt) => {
                if (evt.key === 'Enter' || evt.key === ' ') {
                  evt.preventDefault();
                  handleSelect();
                }
              });
              const startNestedX = pos.side === 'right' ? groupNode.x + groupNode.rx : groupNode.x - groupNode.rx;
              const endNestedX = pos.side === 'right' ? itemX - itemNode.rx : itemX + itemNode.rx;
              const ctrlNestedX = startNestedX + (endNestedX - startNestedX) * 0.6;
              path(
                nestedConnectors,
                `M ${startNestedX} ${groupY} C ${ctrlNestedX} ${groupY}, ${ctrlNestedX} ${itemY}, ${endNestedX} ${itemY}`,
                { stroke: cat.color, sw: 1.4, op: 0.55 }
              );
            });

            slotCursor += branch.slots;
          } else {
            const svc = branch.entry;
            const itemY = startY + slotCursor * ITEM_SPACING;
            const itemX = pos.side === 'right' ? pos.x + ITEM_GAP : pos.x - ITEM_GAP;
            const label = formatLabel(svc.name);
            const itemNode = createNode(leafLayer, itemX, itemY, label, {
              fill: palette.surface,
              stroke: cat.color,
              sw: 1.5,
              padX: 20,
              padY: 12,
              cls: 'small',
            });
            if (searchActive && branch.highlight) {
              itemNode.group.classList.add('search-hit');
            }
            const serviceId = makeServiceKey(svc);
            const occurrence = serviceOccurrences.get(serviceId) || 0;
            serviceOccurrences.set(serviceId, occurrence + 1);
            const serviceKey = buildCompositeKey(serviceId, occurrence);
            const registryEntry = {
              group: itemNode.group,
              service: svc,
              categoryName: cat.category,
              groupName: '',
              language: activeLang,
              serviceId,
              occurrence,
            };
            if (serviceKey) {
              serviceNodeRegistry.set(serviceKey, registryEntry);
              itemNode.group.dataset.serviceKey = serviceKey;
            }
            itemNode.group.classList.add('service-node');
            itemNode.group.style.cursor = 'pointer';
            itemNode.group.setAttribute('aria-label', svc.name);
            itemNode.group.setAttribute('role', 'button');
            itemNode.group.setAttribute('tabindex', '0');
            const toggleHover = (state) => {
              if (state) {
                itemNode.group.classList.add('service-hover');
              } else {
                itemNode.group.classList.remove('service-hover');
              }
            };
            itemNode.group.addEventListener('mouseenter', () => toggleHover(true));
            itemNode.group.addEventListener('mouseleave', () => toggleHover(false));
            itemNode.group.addEventListener('focus', () => toggleHover(true));
            itemNode.group.addEventListener('blur', () => toggleHover(false));
            const handleSelect = () => {
              selectServiceEntry(serviceKey, registryEntry);
            };
            itemNode.group.addEventListener('click', (evt) => {
              evt.preventDefault();
              evt.stopPropagation();
              handleSelect();
            });
            itemNode.group.addEventListener('keypress', (evt) => {
              if (evt.key === 'Enter' || evt.key === ' ') {
                evt.preventDefault();
                handleSelect();
              }
            });
            const startBranchX = pos.side === 'right' ? node.x + node.rx : node.x - node.rx;
            const endBranchX = pos.side === 'right' ? itemX - itemNode.rx : itemX + itemNode.rx;
            const ctrlBranchX = startBranchX + (endBranchX - startBranchX) * 0.6;
            path(
              branchConnectors,
              `M ${startBranchX} ${node.y} C ${ctrlBranchX} ${node.y}, ${ctrlBranchX} ${itemY}, ${endBranchX} ${itemY}`,
              { stroke: cat.color, sw: 1.6, op: 0.6 }
            );

            slotCursor += branch.slots;
          }
        });
      });

      refreshSelectionFromRegistry();
    }


    // Init
    ensureResourceMetadata()
      .then(() => {
        if (selectedServiceData) {
          renderServiceDetails(selectedServiceData);
        }
      })
      .catch(() => {
        // already logged inside ensureResourceMetadata
      });
    applyThemeAttributes(theme);
    setLang(lang).catch((error) => {
      console.error('Failed to initialize language', error);
    });
  </script>
</body>
</html>
