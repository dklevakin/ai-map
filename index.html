<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AI Compass ‚Äî –∫–∞—Ä—Ç–∞ –®–Ü —Å–µ—Ä–≤—ñ—Å—ñ–≤</title>
  <link
    rel="icon"
    type="image/svg+xml"
    href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0' stop-color='%231e3a8a'/%3E%3Cstop offset='1' stop-color='%230ea5e9'/%3E%3C/linearGradient%3E%3C/defs%3E%3Ccircle cx='32' cy='32' r='30' fill='url(%23g)'/%3E%3Cpolygon points='32,14 41,32 32,50 23,32' fill='%23f8fafc'/%3E%3Ccircle cx='32' cy='32' r='6' fill='%231f2937'/%3E%3C/svg%3E"
  />
  <style>
    html,
    body {
      height: 100%;
    }
    body {
      --color-body-bg: #0b1120;
      --color-text-primary: #e2e8f0;
      --color-top-banner-bg: #0f172a;
      --color-top-banner-text: #e2e8f0;
      --color-top-banner-border: rgba(148, 163, 184, 0.18);
      --color-banner-pill-bg: rgba(148, 163, 184, 0.22);
      --color-banner-pill-text: #bae6fd;
      --color-hero-bg: linear-gradient(135deg, #0b1120 0%, #1e293b 100%);
      --color-hero-border: rgba(148, 163, 184, 0.22);
      --color-hero-title: #f8fafc;
      --color-hero-subtitle: #cbd5f5;
      --color-hero-description: #94a3b8;
      --color-map-heading: #e2e8f0;
      --color-search-bg: #111827;
      --color-search-border: rgba(148, 163, 184, 0.4);
      --color-search-text: #e2e8f0;
      --color-search-placeholder: #64748b;
      --color-search-focus: #60a5fa;
      --color-search-focus-ring: rgba(96, 165, 250, 0.28);
      --color-button-bg: #1e293b;
      --color-button-text: #e2e8f0;
      --color-button-hover-bg: #273449;
      --color-button-active-bg: #2563eb;
      --color-button-active-text: #f8fafc;
      --color-button-active-shadow: rgba(37, 99, 235, 0.35);
      --color-card-bg: #111827;
      --color-card-border: rgba(148, 163, 184, 0.25);
      --color-card-shadow: 0 12px 32px rgba(2, 6, 23, 0.7);
      --info-note-color: #94a3b8;
      --color-footer-bg: #020617;
      --color-footer-text: #cbd5f5;
      --color-footer-border: rgba(148, 163, 184, 0.18);
      --color-footer-title: #f8fafc;
      --surface-color: #0f172a;
      --surface-border: rgba(148, 163, 184, 0.35);
      --node-text: #f8fafc;
      --muted-text: #94a3b8;
      --link-text: #60a5fa;
      --error-text: #fca5a5;
      --tooltip-bg: #020617;
      --tooltip-text: #f8fafc;
      margin: 0;
      min-height: 100%;
      display: flex;
      flex-direction: column;
      background: var(--color-body-bg);
      color: var(--color-text-primary);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      transition: background 0.3s ease, color 0.3s ease;
    }
    body[data-theme="dark"] {
      color-scheme: dark;
    }
    body[data-theme="light"] {
      color-scheme: light;
      --color-body-bg: #f9fafb;
      --color-text-primary: #111827;
      --color-top-banner-bg: #1f2937;
      --color-top-banner-text: #f9fafb;
      --color-top-banner-border: rgba(255, 255, 255, 0.08);
      --color-banner-pill-bg: rgba(255, 255, 255, 0.12);
      --color-banner-pill-text: #e0f2fe;
      --color-hero-bg: linear-gradient(135deg, #dbeafe 0%, #f8fafc 100%);
      --color-hero-border: #e5e7eb;
      --color-hero-title: #0f172a;
      --color-hero-subtitle: #1f2937;
      --color-hero-description: #374151;
      --color-map-heading: #0f172a;
      --color-search-bg: #fff;
      --color-search-border: #d1d5db;
      --color-search-text: #0f172a;
      --color-search-placeholder: #9ca3af;
      --color-search-focus: #2563eb;
      --color-search-focus-ring: rgba(37, 99, 235, 0.14);
      --color-button-bg: #e5e7eb;
      --color-button-text: #1f2937;
      --color-button-hover-bg: #d1d5db;
      --color-button-active-bg: #2563eb;
      --color-button-active-text: #fff;
      --color-button-active-shadow: rgba(37, 99, 235, 0.18);
      --color-card-bg: #fff;
      --color-card-border: #e5e7eb;
      --color-card-shadow: 0 12px 32px rgba(15, 23, 42, 0.12);
      --info-note-color: #4b5563;
      --color-footer-bg: #0f172a;
      --color-footer-text: #e5e7eb;
      --color-footer-border: rgba(255, 255, 255, 0.08);
      --color-footer-title: #f9fafb;
      --surface-color: #fff;
      --surface-border: #d1d5db;
      --node-text: #111827;
      --muted-text: #e5e7eb;
      --link-text: #60a5fa;
      --error-text: #b91c1c;
      --tooltip-bg: #111827;
      --tooltip-text: #fff;
    }
    main {
      flex: 1;
    }
    .wrap {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 16px;
      box-sizing: border-box;
    }
    .top-banner {
      background: var(--color-top-banner-bg);
      color: var(--color-top-banner-text);
      border-bottom: 1px solid var(--color-top-banner-border);
      transition: background 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }
    .banner-inner {
      padding: 10px 16px;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 13px;
      letter-spacing: 0.01em;
      text-align: center;
    }
    .banner-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px 10px;
      border-radius: 999px;
      background: var(--color-banner-pill-bg);
      color: var(--color-banner-pill-text);
      font-weight: 600;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      transition: background 0.3s ease, color 0.3s ease;
    }
    .hero {
      background: var(--color-hero-bg);
      border-bottom: 1px solid var(--color-hero-border);
      transition: background 0.3s ease, border-color 0.3s ease;
    }
    .hero-inner {
      padding: 48px 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: flex-start;
    }
    .hero-label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: #1d4ed8;
      color: #fff;
      padding: 6px 14px;
      border-radius: 999px;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }
    .hero-title {
      margin: 0;
      font-size: 32px;
      line-height: 1.2;
      font-weight: 700;
      color: var(--color-hero-title);
      transition: color 0.3s ease;
    }
    .hero-subtitle {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: var(--color-hero-subtitle);
      transition: color 0.3s ease;
    }
    .hero-description {
      margin: 0;
      max-width: 640px;
      font-size: 15px;
      line-height: 1.6;
      color: var(--color-hero-description);
      transition: color 0.3s ease;
    }
    .main-content {
      padding: 40px 16px 48px;
    }
    .bar {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      margin-bottom: 18px;
      flex-wrap: wrap;
      gap: 12px;
    }
    .bar-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .search-input {
      flex: 1 1 240px;
      min-width: 160px;
      width: min(100%, 320px);
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid var(--color-search-border);
      background: var(--color-search-bg);
      color: var(--color-search-text);
      font-size: 14px;
      line-height: 1.4;
      transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
      box-sizing: border-box;
    }
    .search-input::placeholder {
      color: var(--color-search-placeholder);
    }
    .search-input:focus {
      outline: none;
      border-color: var(--color-search-focus);
      box-shadow: 0 0 0 3px var(--color-search-focus-ring);
    }
    .map-heading {
      margin: 0;
      font-size: 22px;
      font-weight: 700;
      color: var(--color-map-heading);
      transition: color 0.3s ease;
    }
    .language-toggle {
      display: inline-flex;
      gap: 8px;
    }
    .theme-toggle {
      display: inline-flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .btn {
      border: 0;
      padding: 8px 14px;
      border-radius: 10px;
      cursor: pointer;
      background: var(--color-button-bg);
      font-size: 13px;
      font-weight: 600;
      color: var(--color-button-text);
      transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }
    .btn:hover {
      background: var(--color-button-hover-bg);
    }
    .btn.active {
      background: var(--color-button-active-bg);
      color: var(--color-button-active-text);
      box-shadow: 0 8px 16px var(--color-button-active-shadow);
    }
    .card {
      background: var(--color-card-bg);
      border-radius: 16px;
      box-shadow: var(--color-card-shadow);
      overflow: auto;
      border: 1px solid var(--color-card-border);
      transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
    }
    svg {
      display: block;
      width: 100%;
      height: auto;
      min-height: 640px;
    }
    .info-note {
      color: var(--info-note-color);
      font-size: 13px;
      margin-top: 14px;
      line-height: 1.5;
      transition: color 0.3s ease;
    }
    .tip {
      pointer-events: none;
    }
    .small {
      font-size: 11px;
      font-weight: 600;
      fill: var(--node-text);
    }
    .normal {
      font-size: 12px;
      font-weight: 600;
      fill: var(--node-text);
    }
    .large {
      font-size: 16px;
      font-weight: 700;
      fill: var(--node-text);
    }
    .muted {
      font-size: 13px;
      font-weight: 500;
      fill: var(--muted-text);
    }
    .link {
      font-size: 11px;
      fill: var(--link-text);
      text-decoration: underline;
    }
    .search-hit text {
      font-weight: 700;
    }
    .search-hit ellipse {
      fill-opacity: 0.24;
      stroke-width: 2.6;
    }
    .site-footer {
      background: var(--color-footer-bg);
      color: var(--color-footer-text);
      padding: 28px 0;
      border-top: 1px solid var(--color-footer-border);
      transition: background 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }
    .footer-inner {
      padding: 0 16px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 13px;
      line-height: 1.6;
    }
    .footer-title {
      font-weight: 600;
      color: var(--color-footer-title);
      letter-spacing: 0.01em;
      transition: color 0.3s ease;
    }
    .footer-theme {
      margin-top: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    @media (max-width: 640px) {
      .hero-inner {
        padding: 36px 16px;
      }
      .bar-controls {
        width: 100%;
        justify-content: flex-start;
      }
      .search-input {
        flex: 1 1 100%;
        min-width: 0;
      }
      .hero-title {
        font-size: 26px;
      }
      .hero-subtitle {
        font-size: 16px;
      }
      .main-content {
        padding: 32px 16px 40px;
      }
      svg {
        min-height: 540px;
      }
    }
  </style>
</head>
<body data-theme="dark">
  <div class="top-banner">
    <div class="wrap banner-inner">
      <span class="banner-pill">AI Compass</span>
      <span id="bannerText">–ë—ñ–±–ª—ñ–æ—Ç–µ–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–µ–Ω–∏—Ö AI —Å–µ—Ä–≤—ñ—Å—ñ–≤ –¥–ª—è –º–∞—Ä–∫–µ—Ç–∏–Ω–≥—É, –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü—ñ—ó —Ç–∞ –∞–Ω–∞–ª—ñ—Ç–∏–∫–∏.</span>
    </div>
  </div>

  <header class="hero">
    <div class="wrap hero-inner">
      <span class="hero-label">AI Compass</span>
      <h1 id="heroTitle" class="hero-title">–í–∞—à –∫–æ–º–ø–∞—Å —É —Å–≤—ñ—Ç—ñ –®–Ü —Å–µ—Ä–≤—ñ—Å—ñ–≤</h1>
      <p id="heroSubtitle" class="hero-subtitle">–í—ñ–¥–∫—Ä–∏–≤–∞–π—Ç–µ –ø–µ—Ä–µ–≤—ñ—Ä–µ–Ω—ñ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏ –¥–ª—è –±—ñ–∑–Ω–µ—Å—É, —Ç–≤–æ—Ä—á–æ—Å—Ç—ñ –π –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü—ñ—ó.</p>
      <p id="heroDescription" class="hero-description">
        –ü–µ—Ä–µ–º–∏–∫–∞–π—Ç–µ –º–æ–≤—É, –æ–±–∏—Ä–∞–π—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é —Ç–∞ –Ω–∞—Ç–∏—Å–∫–∞–π—Ç–µ –Ω–∞ —Å–µ—Ä–≤—ñ—Å–∏, —â–æ–± —à–≤–∏–¥–∫–æ –∑–Ω–∞–π—Ç–∏ –ø–æ—Ç—Ä—ñ–±–Ω–∏–π —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç —ñ –ø–µ—Ä–µ–π—Ç–∏ –Ω–∞ –π–æ–≥–æ —Å–∞–π—Ç.
      </p>
    </div>
  </header>

  <main>
    <div class="wrap main-content">
      <div class="bar">
        <h2 id="mapHeading" class="map-heading">–ú–∞–ø–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ–π AI‚Äë—Å–µ—Ä–≤—ñ—Å—ñ–≤</h2>
        <div class="bar-controls">
          <input
            id="searchInput"
            class="search-input"
            type="search"
            autocomplete="off"
            spellcheck="false"
            enterkeyhint="search"
          />
          <div class="language-toggle">
            <button id="uaBtn" class="btn active">UA</button>
            <button id="enBtn" class="btn">EN</button>
          </div>
          <div class="theme-toggle" data-theme-toggle="header">
            <button id="headerDarkBtn" class="btn" type="button" data-theme-option="dark">üåô –¢–µ–º–Ω–∞</button>
            <button id="headerLightBtn" class="btn" type="button" data-theme-option="light">‚òÄÔ∏è –°–≤—ñ—Ç–ª–∞</button>
          </div>
        </div>
      </div>
      <div class="card">
        <svg id="stage" viewBox="0 0 1100 760" aria-label="Mind map canvas"></svg>
      </div>
      <p id="infoNote" class="info-note">
        –Ü–∫–æ–Ω–∫–∏ –ø–æ—Ä—É—á —ñ–∑ –Ω–∞–∑–≤–∞–º–∏ –¥–æ–ø–æ–º–∞–≥–∞—é—Ç—å —à–≤–∏–¥–∫–æ –∑–æ—Ä—ñ—î–Ω—Ç—É–≤–∞—Ç–∏—Å—è. –ö–ª—ñ–∫–Ω—ñ—Ç—å –∫–∞—Ç–µ–≥–æ—Ä—ñ—é, —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏ —Å–µ—Ä–≤—ñ—Å–∏. –ù–∞–≤–µ–¥—ñ—Ç—å –∫—É—Ä—Å–æ—Ä ‚Äî –æ–ø–∏—Å —Ç–∞ –ø–æ—Å–∏–ª–∞–Ω–Ω—è.
      </p>
    </div>
  </main>

  <footer class="site-footer">
    <div class="wrap footer-inner">
      <span class="footer-title">Dmytro Klevakin</span>
      <span id="footerRights">All rights reserved ¬∑ 2024</span>
      <span id="footerTagline">Crafted to help you explore and compare AI solutions with confidence.</span>
      <div class="footer-theme">
        <div class="theme-toggle" data-theme-toggle="footer">
          <button id="footerDarkBtn" class="btn" type="button" data-theme-option="dark">üåô –¢–µ–º–Ω–∞</button>
          <button id="footerLightBtn" class="btn" type="button" data-theme-option="light">‚òÄÔ∏è –°–≤—ñ—Ç–ª–∞</button>
        </div>
      </div>
    </div>
  </footer>

  <script>
    const datasetCache = new Map();
    const datasetPromises = new Map();
    const DATA_PATHS = {
      ua: 'data/ua.json',
      en: 'data/en.json',
    };
    const CATALOG_VERSION = '2024-06-08';
    const CATALOG_CACHE_PREFIX = 'catalog';
    const CATALOG_CACHE_MAX_AGE_MS = 1000 * 60 * 60 * 24; // 24 hours
    let datasetWarmupScheduled = false;

    function getDatasetPath(language) {
      return DATA_PATHS[language] || DATA_PATHS.ua;
    }

    function getDatasetStorageKey(language) {
      return `${CATALOG_CACHE_PREFIX}:${language}:${CATALOG_VERSION}`;
    }

    function removeStoredDataset(language) {
      if (typeof localStorage === 'undefined') return;
      try {
        localStorage.removeItem(getDatasetStorageKey(language));
      } catch (error) {
        console.warn(`Failed to remove cached dataset for ${language}`, error);
      }
    }

    function readStoredDataset(language) {
      if (typeof localStorage === 'undefined') {
        return null;
      }
      const key = getDatasetStorageKey(language);
      try {
        const serialized = localStorage.getItem(key);
        if (!serialized) {
          return null;
        }
        const payload = JSON.parse(serialized);
        if (!payload || typeof payload !== 'object') {
          removeStoredDataset(language);
          return null;
        }
        const { data, cachedAt } = payload;
        if (data == null) {
          removeStoredDataset(language);
          return null;
        }
        const timestamp = typeof cachedAt === 'number' ? cachedAt : 0;
        if (!timestamp || Date.now() - timestamp > CATALOG_CACHE_MAX_AGE_MS) {
          removeStoredDataset(language);
          return null;
        }
        return data;
      } catch (error) {
        console.warn(`Failed to read cached dataset for ${language}`, error);
        removeStoredDataset(language);
        return null;
      }
    }

    function writeStoredDataset(language, data) {
      if (typeof localStorage === 'undefined') {
        return;
      }
      const key = getDatasetStorageKey(language);
      try {
        const payload = JSON.stringify({ cachedAt: Date.now(), data });
        localStorage.setItem(key, payload);
      } catch (error) {
        console.warn(`Failed to persist dataset cache for ${language}`, error);
      }
    }

    async function loadDataset(language) {
      if (datasetCache.has(language)) {
        return datasetCache.get(language);
      }
      if (datasetPromises.has(language)) {
        return datasetPromises.get(language);
      }

      const stored = readStoredDataset(language);
      if (stored !== null) {
        datasetCache.set(language, stored);
        return stored;
      }

      const pathValue = getDatasetPath(language);
      const promise = fetch(pathValue)
        .then((response) => {
          if (!response.ok) {
            throw new Error(`Failed to load dataset: ${response.status} ${response.statusText}`);
          }
          return response.json();
        })
        .then((json) => {
          datasetCache.set(language, json);
          writeStoredDataset(language, json);
          datasetPromises.delete(language);
          return json;
        })
        .catch((error) => {
          datasetPromises.delete(language);
          throw error;
        });
      datasetPromises.set(language, promise);
      return promise;
    }

    function scheduleDatasetWarmup(primaryLanguage) {
      if (datasetWarmupScheduled) {
        return;
      }
      datasetWarmupScheduled = true;
      const languages = Object.keys(DATA_PATHS).filter((code) => code !== primaryLanguage);
      if (!languages.length) {
        return;
      }
      const warmup = () => {
        languages.forEach((code) => {
          loadDataset(code).catch((error) => {
            console.warn(`Failed to prefetch dataset for ${code}`, error);
          });
        });
      };
      if (typeof requestIdleCallback === 'function') {
        requestIdleCallback(() => warmup(), { timeout: 2000 });
      } else {
        setTimeout(warmup, 400);
      }
    }

    const ICONS = {
      'ChatGPT': 'üß†',
      'Claude': 'ü™∂',
      'Google Gemini': '‚ú®',
      'Microsoft Copilot': 'üß≠',
      'Perplexity AI': 'üîé',
      'Mistral Le Chat': 'üå¨Ô∏è',
      'Pi by Inflection': 'üí¨',
      'You.com': 'üîç',
      'Character.AI': 'üé≠',
      'Midjourney': 'üé®',
      'Stable Diffusion': 'üåÄ',
      'Leonardo AI': 'üñåÔ∏è',
      'Canva AI': 'üñºÔ∏è',
      'Adobe Firefly': 'üî•',
      'Ideogram AI': 'üî§',
      'Playground AI': 'üõù',
      'DALL¬∑E': 'üß©',
      'Krea AI': 'üåà',
      'HeyGen': 'üó£Ô∏è',
      'Synthesia': 'üé¨',
      'Runway ML': 'üéûÔ∏è',
      'Pictory': 'ü™Ñ',
      'OpusClip': 'üì±',
      'Descript': 'üéôÔ∏è',
      'Lumen5': 'üìΩÔ∏è',
      'Rephrase.ai': 'üó£Ô∏è',
      'Fliki': 'üîä',
      'Zapier': '‚ö°',
      'Make': 'üß©',
      'n8n': 'ü™¢',
      'UiPath': 'üè≠',
      'Power Automate': 'üîÅ',
      'Bardeen': 'üõ†Ô∏è',
      'Levity': '‚öôÔ∏è',
      'Axiom.ai': 'üß™',
      'Workato': 'ü§ù',
      'Coursera': 'üéì',
      'Udemy': 'üìö',
      'Docebo': 'üè´',
      'LearnWorlds': 'üåê',
      'Evolv AI': 'üìà',
      'Mindsmith': 'üß†',
      'Sana AI': 'üí°',
      'Workera': 'üß¨',
      'CapCut': '‚úÇÔ∏è',
      'VEED.io': 'üìº',
      'Copy.ai': '‚úçÔ∏è',
      'Jasper': 'ü§ñ',
      'Notion AI': 'üóÉÔ∏è',
      'Predis.ai': 'üìù',
      'Tidio': 'üí¨',
      'ManyChat': 'ü§≥',
      'Writesonic': 'üöÄ',
      'Lately AI': 'üìä',
      'Power BI': 'üìä',
      'Tableau': 'üìà',
      'MonkeyLearn': 'üêí',
      'Crayon': 'üñçÔ∏è',
      'Crux': 'üß±',
      'Tellius': 'üîÆ',
      'ThoughtSpot': 'üåü',
      'Obviously AI': 'ü§î',
      'Xero': 'üíº',
      'QuickBooks': 'üßæ',
      'AdCreative.ai': 'üéØ',
      'Shopify AI': 'üõí',
      'Wix AI': 'üèóÔ∏è',
      'Planner 5D': 'üè†',
      'Autodesk AI': 'üè¢',
      'Fashwell AI': 'üëó',
      'Corti': 'üìû',
      'Viz.ai': 'ü©∫',
    };

    const FALLBACK_ICON = '‚ú®';

    const nodeSizeCache = new Map();

    function formatLabel(name) {
      const icon = ICONS[name] || FALLBACK_ICON;
      return `${icon} ${name}`;
    }

    function isGroup(entry) {
      return !!(entry && Array.isArray(entry.items) && entry.items.length);
    }

    function countLeafItems(entries, groupState) {
      if (!Array.isArray(entries)) return 0;
      return entries.reduce((total, entry) => {
        if (!entry) return total;
        if (isGroup(entry)) {
          const items = Array.isArray(entry.items) ? entry.items : [];
          if (groupState && groupState.has(entry.group)) {
            return total + 1 + items.length;
          }
          return total + 1;
        }
        return total + 1;
      }, 0);
    }

    function includesQuery(value, query) {
      return typeof value === 'string' && value.toLowerCase().includes(query);
    }

    function createSearchMeta(cat, query) {
      const entries = Array.isArray(cat.items) ? cat.items : [];
      const branchInfos = entries.map((entry) => {
        if (isGroup(entry)) {
          const items = Array.isArray(entry.items) ? entry.items : [];
          const itemInfos = items.map((svc) => ({
            entry: svc,
            match: includesQuery(svc.name, query) || includesQuery(svc.desc, query),
          }));
          const groupNameMatch = includesQuery(entry.group, query);
          const hasMatch = groupNameMatch || itemInfos.some((info) => info.match);
          return { type: 'group', entry, groupNameMatch, hasMatch, items: itemInfos };
        }
        const match = includesQuery(entry && entry.name, query) || includesQuery(entry && entry.desc, query);
        return { type: 'item', entry, match };
      });
      const catNameMatch = includesQuery(cat.category, query);
      const hasItemMatch = branchInfos.some((branch) => {
        if (branch.type === 'group') return branch.items.some((item) => item.match);
        return branch.match;
      });
      const hasGroupMatch = branchInfos.some((branch) => branch.type === 'group' && branch.groupNameMatch);
      const hasMatch = catNameMatch || branchInfos.some((branch) => (branch.type === 'group' ? branch.hasMatch : branch.match));
      return { hasMatch, catNameMatch, hasItemMatch, hasGroupMatch, branchInfos };
    }

    // State
    let lang = localStorage.getItem('lang') || 'ua';
    let expanded = null; // index of category
    let searchQuery = '';
    let searchTimer = null;
    const expandedGroups = new Map();
    const THEME_STORAGE_KEY = 'theme';
    let theme = localStorage.getItem(THEME_STORAGE_KEY) === 'light' ? 'light' : 'dark';
    let themeColors = {};

    function getGroupState(cat, currentLang = lang) {
      const key = `${currentLang}:${cat.category}`;
      let state = expandedGroups.get(key);
      if (!state) {
        state = new Set();
        expandedGroups.set(key, state);
      }
      return state;
    }

    const stage = document.getElementById('stage');
    const uaBtn = document.getElementById('uaBtn');
    const enBtn = document.getElementById('enBtn');
    const searchInput = document.getElementById('searchInput');
    const heroTitleEl = document.getElementById('heroTitle');
    const heroSubtitleEl = document.getElementById('heroSubtitle');
    const heroDescriptionEl = document.getElementById('heroDescription');
    const mapHeadingEl = document.getElementById('mapHeading');
    const bannerTextEl = document.getElementById('bannerText');
    const infoNoteEl = document.getElementById('infoNote');
    const footerRightsEl = document.getElementById('footerRights');
    const footerTaglineEl = document.getElementById('footerTagline');
    const themeButtons = Array.from(document.querySelectorAll('[data-theme-option]'));

    const COPY = {
      heroTitle: {
        ua: '–í–∞—à –∫–æ–º–ø–∞—Å —É —Å–≤—ñ—Ç—ñ –®–Ü —Å–µ—Ä–≤—ñ—Å—ñ–≤',
        en: 'Your compass through the AI service landscape',
      },
      heroSubtitle: {
        ua: '–í—ñ–¥–∫—Ä–∏–≤–∞–π—Ç–µ –ø–µ—Ä–µ–≤—ñ—Ä–µ–Ω—ñ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏ –¥–ª—è –±—ñ–∑–Ω–µ—Å—É, —Ç–≤–æ—Ä—á–æ—Å—Ç—ñ –π –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü—ñ—ó.',
        en: 'Discover trusted platforms for business, creativity, and automation.',
      },
      heroDescription: {
        ua: '–ü–µ—Ä–µ–º–∏–∫–∞–π—Ç–µ –º–æ–≤—É, –æ–±–∏—Ä–∞–π—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é —Ç–∞ –Ω–∞—Ç–∏—Å–∫–∞–π—Ç–µ –Ω–∞ —Å–µ—Ä–≤—ñ—Å–∏, —â–æ–± —à–≤–∏–¥–∫–æ –∑–Ω–∞–π—Ç–∏ –ø–æ—Ç—Ä—ñ–±–Ω–∏–π —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç —ñ –ø–µ—Ä–µ–π—Ç–∏ –Ω–∞ –π–æ–≥–æ —Å–∞–π—Ç.',
        en: 'Switch the language, pick a category, and click services to quickly find the right tool and jump to its official site.',
      },
      mapHeading: {
        ua: '–ú–∞–ø–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ–π AI‚Äë—Å–µ—Ä–≤—ñ—Å—ñ–≤',
        en: 'Map of AI service categories',
      },
      banner: {
        ua: '–ë—ñ–±–ª—ñ–æ—Ç–µ–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–µ–Ω–∏—Ö AI —Å–µ—Ä–≤—ñ—Å—ñ–≤ –¥–ª—è –º–∞—Ä–∫–µ—Ç–∏–Ω–≥—É, –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü—ñ—ó —Ç–∞ –∞–Ω–∞–ª—ñ—Ç–∏–∫–∏.',
        en: 'Curated AI tools for marketing, automation, and analytics teams.',
      },
      searchPlaceholder: {
        ua: '–ü–æ—à—É–∫ —Å–µ—Ä–≤—ñ—Å—ñ–≤‚Ä¶',
        en: 'Search services‚Ä¶',
      },
      searchAria: {
        ua: '–ü–æ—à—É–∫ —Å–µ—Ä–≤—ñ—Å—ñ–≤ –Ω–∞ –º–∞–ø—ñ',
        en: 'Search services on the map',
      },
      noResults: {
        ua: '–ù–µ–º–∞—î —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ –∑–∞ –∑–∞–ø–∏—Ç–æ–º',
        en: 'No results for this query',
      },
      infoNote: {
        ua: '–Ü–∫–æ–Ω–∫–∏ –ø–æ—Ä—É—á —ñ–∑ –Ω–∞–∑–≤–∞–º–∏ –¥–æ–ø–æ–º–∞–≥–∞—é—Ç—å —à–≤–∏–¥–∫–æ –∑–æ—Ä—ñ—î–Ω—Ç—É–≤–∞—Ç–∏—Å—è. –ö–ª—ñ–∫–Ω—ñ—Ç—å –∫–∞—Ç–µ–≥–æ—Ä—ñ—é, —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏ —Å–µ—Ä–≤—ñ—Å–∏. –ù–∞–≤–µ–¥—ñ—Ç—å –∫—É—Ä—Å–æ—Ä ‚Äî –æ–ø–∏—Å —Ç–∞ –ø–æ—Å–∏–ª–∞–Ω–Ω—è.',
        en: 'Icons highlight each tool. Click a category to expand and hover any service to read the description and open the link.',
      },
      footerRights: {
        ua: '–£—Å—ñ –ø—Ä–∞–≤–∞ –∑–∞—Ö–∏—â–µ–Ω—ñ ¬∑ 2024',
        en: 'All rights reserved ¬∑ 2024',
      },
      footerTagline: {
        ua: '–°—Ç–≤–æ—Ä–µ–Ω–æ, —â–æ–± –¥–æ–ø–æ–º–æ–≥—Ç–∏ –¥–æ—Å–ª—ñ–¥–∂—É–≤–∞—Ç–∏ –π –ø–æ—Ä—ñ–≤–Ω—é–≤–∞—Ç–∏ AI-—Ä—ñ—à–µ–Ω–Ω—è –≤–ø–µ–≤–Ω–µ–Ω–æ.',
        en: 'Crafted to help you explore and compare AI solutions with confidence.',
      },
      themeDark: {
        ua: '–¢–µ–º–Ω–∞',
        en: 'Dark',
      },
      themeLight: {
        ua: '–°–≤—ñ—Ç–ª–∞',
        en: 'Light',
      },
      loading: {
        ua: '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è‚Ä¶',
        en: 'Loading‚Ä¶',
      },
      loadError: {
        ua: '–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –¥–∞–Ω—ñ',
        en: 'Failed to load data',
      },
    };

    function applyCopy() {
      if (bannerTextEl) bannerTextEl.textContent = COPY.banner[lang];
      if (heroTitleEl) heroTitleEl.textContent = COPY.heroTitle[lang];
      if (heroSubtitleEl) heroSubtitleEl.textContent = COPY.heroSubtitle[lang];
      if (heroDescriptionEl) heroDescriptionEl.textContent = COPY.heroDescription[lang];
      if (mapHeadingEl) mapHeadingEl.textContent = COPY.mapHeading[lang];
      if (searchInput) {
        searchInput.placeholder = COPY.searchPlaceholder[lang];
        searchInput.setAttribute('aria-label', COPY.searchAria[lang]);
      }
      if (infoNoteEl) infoNoteEl.textContent = COPY.infoNote[lang];
      if (footerRightsEl) footerRightsEl.textContent = COPY.footerRights[lang];
      if (footerTaglineEl) footerTaglineEl.textContent = COPY.footerTagline[lang];
      const themeSuffix = lang === 'ua' ? '—Ç–µ–º–∞' : 'theme';
      themeButtons.forEach((btn) => {
        if (!btn) return;
        const option = btn.dataset.themeOption;
        if (option === 'dark') {
          const label = COPY.themeDark[lang];
          const text = `üåô ${label}`;
          const fullLabel = `${label} ${themeSuffix}`;
          btn.textContent = text;
          btn.setAttribute('aria-label', fullLabel);
          btn.setAttribute('title', fullLabel);
        } else if (option === 'light') {
          const label = COPY.themeLight[lang];
          const text = `‚òÄÔ∏è ${label}`;
          const fullLabel = `${label} ${themeSuffix}`;
          btn.textContent = text;
          btn.setAttribute('aria-label', fullLabel);
          btn.setAttribute('title', fullLabel);
        }
      });
      document.documentElement.lang = lang === 'ua' ? 'uk' : 'en';
    }

    function readThemeColors() {
      const styles = getComputedStyle(document.body);
      return {
        surface: styles.getPropertyValue('--surface-color').trim() || '#fff',
        surfaceBorder: styles.getPropertyValue('--surface-border').trim() || '#d1d5db',
        nodeText: styles.getPropertyValue('--node-text').trim() || '#111827',
        errorText: styles.getPropertyValue('--error-text').trim() || '#b91c1c',
        tooltipBg: styles.getPropertyValue('--tooltip-bg').trim() || '#111827',
        tooltipText: styles.getPropertyValue('--tooltip-text').trim() || '#fff',
      };
    }

    function updateThemeToggleState(activeTheme) {
      themeButtons.forEach((btn) => {
        if (!btn) return;
        const isActive = btn.dataset.themeOption === activeTheme;
        btn.classList.toggle('active', isActive);
        btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      });
    }

    function applyThemeAttributes(nextTheme) {
      const normalized = nextTheme === 'light' ? 'light' : 'dark';
      document.body.setAttribute('data-theme', normalized);
      updateThemeToggleState(normalized);
      themeColors = readThemeColors();
    }

    function changeTheme(nextTheme) {
      const normalized = nextTheme === 'light' ? 'light' : 'dark';
      if (normalized === theme) {
        updateThemeToggleState(normalized);
        return;
      }
      theme = normalized;
      localStorage.setItem(THEME_STORAGE_KEY, normalized);
      applyThemeAttributes(normalized);
      render().catch((error) => {
        console.error('Failed to render dataset after theme change', error);
      });
    }

    themeButtons.forEach((btn) => {
      if (!btn) return;
      btn.addEventListener('click', () => {
        const option = btn.dataset.themeOption;
        if (option) {
          changeTheme(option);
        }
      });
    });

    async function setLang(l) {
      lang = l;
      localStorage.setItem('lang', l);
      uaBtn.classList.toggle('active', l==='ua');
      enBtn.classList.toggle('active', l==='en');
      expanded = null;
      expandedGroups.clear();
      nodeSizeCache.clear();
      applyCopy();
      if (searchInput) {
        searchInput.value = searchQuery;
      }
      await render();
      scheduleDatasetWarmup(l);
    }

    uaBtn.onclick = () => {
      setLang('ua').catch((error) => {
        console.error('Failed to switch to Ukrainian dataset', error);
      });
    };
    enBtn.onclick = () => {
      setLang('en').catch((error) => {
        console.error('Failed to switch to English dataset', error);
      });
    };

    if (searchInput) {
      searchInput.value = searchQuery;
      const commitSearch = () => {
        searchQuery = searchInput.value;
        render().catch((error) => {
          console.error('Failed to render dataset after search update', error);
        });
      };
      const scheduleSearch = () => {
        if (searchTimer) {
          clearTimeout(searchTimer);
        }
        searchTimer = setTimeout(commitSearch, 180);
      };
      searchInput.addEventListener('input', scheduleSearch);
      searchInput.addEventListener('search', scheduleSearch);
    }

    // Drawing primitives
    function group(parent) {
      const el = document.createElementNS('http://www.w3.org/2000/svg','g');
      parent.appendChild(el);
      return el;
    }
    function path(parent, d, opts={}) {
      const el = document.createElementNS('http://www.w3.org/2000/svg','path');
      el.setAttribute('d', d);
      el.setAttribute('fill', opts.fill || 'none');
      if (opts.stroke) el.setAttribute('stroke', opts.stroke);
      if (opts.sw) el.setAttribute('stroke-width', opts.sw);
      if (opts.op) el.setAttribute('stroke-opacity', opts.op);
      if (opts.sd) el.setAttribute('stroke-dasharray', opts.sd);
      parent.appendChild(el);
      return el;
    }
    function createNode(parent, x, y, label, opts={}) {
      const g = group(parent);
      g.setAttribute('transform', `translate(${x},${y})`);
      const textEl = document.createElementNS('http://www.w3.org/2000/svg','text');
      textEl.setAttribute('text-anchor','middle');
      textEl.setAttribute('dominant-baseline','middle');
      textEl.setAttribute('class', opts.cls || 'normal');
      textEl.textContent = label;
      g.appendChild(textEl);
      const padX = opts.padX ?? 18;
      const padY = opts.padY ?? 12;
      const classKey = opts.cls || 'normal';
      const cachedByLabel = nodeSizeCache.get(label);
      let width;
      let height;
      if (cachedByLabel && cachedByLabel.has(classKey)) {
        const cachedSize = cachedByLabel.get(classKey);
        width = cachedSize.width;
        height = cachedSize.height;
      } else {
        const bbox = textEl.getBBox();
        width = bbox.width;
        height = bbox.height;
        let entry = cachedByLabel;
        if (!entry) {
          entry = new Map();
          nodeSizeCache.set(label, entry);
        }
        entry.set(classKey, { width, height });
      }
      const rx = width / 2 + padX;
      const ry = height / 2 + padY;
      const ell = document.createElementNS('http://www.w3.org/2000/svg','ellipse');
      ell.setAttribute('cx', 0);
      ell.setAttribute('cy', 0);
      ell.setAttribute('rx', rx);
      ell.setAttribute('ry', ry);
      ell.setAttribute('fill', opts.fill || '#fff');
      if (opts.fillOpacity != null) ell.setAttribute('fill-opacity', opts.fillOpacity);
      if (opts.stroke) ell.setAttribute('stroke', opts.stroke);
      if (opts.sw) ell.setAttribute('stroke-width', opts.sw);
      if (opts.op) ell.setAttribute('opacity', opts.op);
      g.insertBefore(ell, textEl);
      return { group: g, text: textEl, ellipse: ell, rx, ry, x, y };
    }

    // Tooltip management
    let tipGroup = null;
    let measureTextEl = null;

    function wrapText(text, maxWidth) {
      const lines = [];
      if (!text) return lines;
      if (!measureTextEl) {
        measureTextEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        measureTextEl.setAttribute('class', 'muted');
        measureTextEl.setAttribute('visibility', 'hidden');
      }
      if (measureTextEl.parentNode !== stage) {
        stage.appendChild(measureTextEl);
      }
      const words = text.split(/\s+/);
      let current = '';
      words.forEach((word) => {
        const candidate = current ? `${current} ${word}` : word;
        measureTextEl.textContent = candidate;
        if (measureTextEl.getComputedTextLength() <= maxWidth) {
          current = candidate;
        } else {
          if (current) {
            lines.push(current);
            current = '';
          }
          measureTextEl.textContent = word;
          if (measureTextEl.getComputedTextLength() > maxWidth) {
            lines.push(word);
            current = '';
          } else {
            current = word;
          }
        }
      });
      if (current) lines.push(current);
      return lines;
    }

    function showTip(x, y, title, desc, href) {
      hideTip();
      const palette = themeColors.surface ? themeColors : readThemeColors();
      tipGroup = group(stage);
      tipGroup.setAttribute('class','tip');
      const w = 340;
      const pad = 14;
      const maxWidth = w - pad * 2;
      const lines = wrapText(desc, maxWidth);
      const lineHeight = 18;
      const descHeight = Math.max(lineHeight, lines.length * lineHeight);
      const titleHeight = 18;
      const linkHeight = 16;
      const gap = 12;
      const h = Math.max(170, pad + titleHeight + gap + descHeight + gap + linkHeight + pad);
      const vb = (stage.getAttribute('viewBox') || '0 0 1100 760').split(' ').map(Number);
      const viewW = vb[2] || 1100;
      const viewH = vb[3] || 760;
      let tx = x + 18;
      let ty = y - h - 14;
      if (tx + w > viewW - 12) tx = x - w - 18;
      if (tx < 12) tx = 12;
      if (ty < 12) ty = y + 18;
      if (ty + h > viewH - 12) ty = Math.max(12, viewH - h - 12);
      const bg = document.createElementNS('http://www.w3.org/2000/svg','rect');
      bg.setAttribute('x', tx); bg.setAttribute('y', ty); bg.setAttribute('rx', 12); bg.setAttribute('ry', 12);
      bg.setAttribute('width', w); bg.setAttribute('height', h);
      bg.setAttribute('fill', palette.tooltipBg || '#111827'); bg.setAttribute('opacity', '0.95');
      tipGroup.appendChild(bg);
      const t1 = document.createElementNS('http://www.w3.org/2000/svg','text');
      t1.setAttribute('x', tx + pad); t1.setAttribute('y', ty + pad + 6); t1.setAttribute('fill', palette.tooltipText || '#fff');
      t1.setAttribute('style','font-weight:700; font-size:13px;');
      t1.textContent = title;
      tipGroup.appendChild(t1);
      const t2 = document.createElementNS('http://www.w3.org/2000/svg','text');
      t2.setAttribute('x', tx + pad);
      t2.setAttribute('y', ty + pad + titleHeight + 4);
      t2.setAttribute('class', 'muted');
      t2.setAttribute('dominant-baseline', 'hanging');
      lines.forEach((line, idx) => {
        const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
        tspan.setAttribute('x', tx + pad);
        tspan.setAttribute('dy', idx === 0 ? 0 : lineHeight);
        tspan.textContent = line;
        t2.appendChild(tspan);
      });
      tipGroup.appendChild(t2);
      const link = document.createElementNS('http://www.w3.org/2000/svg','a');
      link.setAttribute('href', href); link.setAttribute('target','_blank'); link.setAttribute('rel','noreferrer');
      const t3 = document.createElementNS('http://www.w3.org/2000/svg','text');
      t3.setAttribute('x', tx + pad);
      t3.setAttribute('y', ty + h - pad);
      t3.setAttribute('class','link');
      t3.textContent = (lang==='ua' ? '–í—ñ–¥–∫—Ä–∏—Ç–∏ —Å–∞–π—Ç ‚Üí' : 'Visit site ‚Üí');
      link.appendChild(t3);
      tipGroup.appendChild(link);
    }
    function hideTip() {
      if (tipGroup) {
        if (tipGroup.parentNode) tipGroup.parentNode.removeChild(tipGroup);
        tipGroup = null;
      }
    }

    async function render() {
      const activeLang = lang;
      const palette = themeColors.surface ? themeColors : readThemeColors();
      hideTip();
      const hadMeasureText = measureTextEl && measureTextEl.parentNode === stage;
      stage.innerHTML = '';

      if (hadMeasureText) {
        stage.appendChild(measureTextEl);
      }

      if (!datasetCache.has(activeLang)) {
        stage.setAttribute('viewBox', '0 0 400 200');
        stage.setAttribute('height', 200);
        stage.style.height = '200px';
        const loadingLayer = group(stage);
        const loadingNode = createNode(loadingLayer, 200, 100, COPY.loading[activeLang], {
          fill: palette.surface,
          stroke: palette.surfaceBorder,
          sw: 1.6,
          padX: 24,
          padY: 16,
          cls: 'normal',
        });
        loadingNode.text.setAttribute('fill', palette.nodeText);
      }

      let data;
      try {
        data = await loadDataset(activeLang);
      } catch (error) {
        stage.innerHTML = '';
        if (hadMeasureText) {
          stage.appendChild(measureTextEl);
        }
        stage.setAttribute('viewBox', '0 0 400 200');
        stage.setAttribute('height', 200);
        stage.style.height = '200px';
        const errorLayer = group(stage);
        const errorNode = createNode(errorLayer, 200, 100, COPY.loadError[activeLang], {
          fill: palette.surface,
          stroke: palette.errorText,
          sw: 1.6,
          padX: 24,
          padY: 16,
          cls: 'normal',
        });
        errorNode.text.setAttribute('fill', palette.errorText);
        console.error('Failed to load dataset', error);
        return;
      }

      if (activeLang !== lang) {
        return;
      }

      stage.innerHTML = '';
      if (hadMeasureText) {
        stage.appendChild(measureTextEl);
      }

      const connectorsLayer = group(stage);
      const nodesLayer = group(stage);

      if (!Array.isArray(data)) {
        data = [];
      }
      const CATEGORY_GAP = 240;
      const ITEM_GAP = 250;
      const GROUP_GAP = 170;
      const BASE_SPACING = 110;
      const ITEM_SPACING = 64;
      const MARGIN_Y = 120;
      const CANVAS_WIDTH = 1200;
      const MIN_HEIGHT = 680;

      const query = (searchQuery || '').trim().toLowerCase();
      const searchActive = query.length > 0;
      const searchMeta = searchActive ? data.map((cat) => createSearchMeta(cat, query)) : [];
      const visibleIndices = [];

      data.forEach((cat, idx) => {
        if (!searchActive) {
          visibleIndices.push(idx);
        } else if (searchMeta[idx] && searchMeta[idx].hasMatch) {
          visibleIndices.push(idx);
        }
      });

      if (searchActive && visibleIndices.length === 0) {
        const height = MIN_HEIGHT;
        stage.setAttribute('viewBox', `0 0 ${CANVAS_WIDTH} ${height}`);
        stage.setAttribute('height', height);
        stage.style.height = `${height}px`;
        const message = createNode(nodesLayer, CANVAS_WIDTH / 2, height / 2, COPY.noResults[activeLang], {
          fill: palette.surface,
          stroke: palette.surfaceBorder,
          sw: 1.6,
          padX: 28,
          padY: 18,
          cls: 'normal',
        });
        message.text.setAttribute('fill', palette.nodeText);
        return;
      }

      const total = visibleIndices.length;
      const rightCount = Math.ceil(total / 2);
      const leftCount = total - rightCount;

      const weights = visibleIndices.map((idx) => {
        if (searchActive) {
          const meta = searchMeta[idx];
          if (!meta) return 1.4;
          const entries = Array.isArray(data[idx].items) ? data[idx].items : [];
          let visibleCount = 0;
          entries.forEach((entry, entryIdx) => {
            if (isGroup(entry)) {
              const branchMeta = meta.branchInfos ? meta.branchInfos[entryIdx] : null;
              if (!branchMeta || !branchMeta.hasMatch) return;
              visibleCount += 1;
              const matchedItems = branchMeta.items.filter((info) => info.match);
              visibleCount += matchedItems.length;
            } else if (entry && entry.name) {
              const branchMeta = meta.branchInfos ? meta.branchInfos[entryIdx] : null;
              if (branchMeta && branchMeta.match) {
                visibleCount += 1;
              }
            }
          });
          return Math.max(1.6, visibleCount ? visibleCount * 0.9 : 1.4);
        }
        if (expanded === idx) {
          const groupState = getGroupState(data[idx], activeLang);
          const leafCount = countLeafItems(data[idx].items, groupState);
          return Math.max(1.6, leafCount * 0.9);
        }
        return 1;
      });

      const sum = (arr) => arr.reduce((acc, val) => acc + val, 0);
      const rightWeight = sum(weights.slice(0, rightCount));
      const leftWeight = sum(weights.slice(rightCount));
      const span = (weight, count) => (weight > 0 ? weight : Math.max(count, 1));

      const height = Math.max(
        MIN_HEIGHT,
        MARGIN_Y * 2 + span(rightWeight, rightCount) * BASE_SPACING,
        MARGIN_Y * 2 + span(leftWeight, leftCount) * BASE_SPACING
      );
      const availableHeight = height - MARGIN_Y * 2;

      stage.setAttribute('viewBox', `0 0 ${CANVAS_WIDTH} ${height}`);
      stage.setAttribute('height', height);
      stage.style.height = `${height}px`;

      const rootX = CANVAS_WIDTH / 2;
      const rootY = height / 2;

      const positions = new Map();
      const layoutSide = (subset, subsetWeights, side) => {
        if (!subset.length) return;
        const totalWeight = subsetWeights.reduce((acc, val) => acc + val, 0) || subset.length;
        let cursor = MARGIN_Y;
        subset.forEach((idx, order) => {
          const weight = subsetWeights[order] || totalWeight / subset.length;
          const portion = weight / totalWeight;
          const segment = portion * availableHeight;
          const centerY = cursor + segment / 2;
          positions.set(idx, {
            x: side === 'right' ? rootX + CATEGORY_GAP : rootX - CATEGORY_GAP,
            y: centerY,
            side,
          });
          cursor += segment;
        });
      };

      layoutSide(visibleIndices.slice(0, rightCount), weights.slice(0, rightCount), 'right');
      layoutSide(visibleIndices.slice(rightCount), weights.slice(rightCount), 'left');

      const rootLabel = 'AI Compass';
      const rootNode = createNode(nodesLayer, rootX, rootY, rootLabel, {
        fill: palette.surface,
        stroke: palette.nodeText,
        sw: 2,
        padX: 30,
        padY: 20,
        cls: 'large',
      });

      const catNodes = new Array(data.length);
      visibleIndices.forEach((idx) => {
        const pos = positions.get(idx);
        if (!pos) return;
        const cat = data[idx];
        const node = createNode(nodesLayer, pos.x, pos.y, cat.category, {
          fill: cat.color,
          fillOpacity: 0.12,
          stroke: cat.color,
          sw: 2,
          padX: 26,
          padY: 16,
          cls: 'normal',
        });
        if (!searchActive) {
          node.group.style.cursor = 'pointer';
          node.group.setAttribute('role', 'button');
          node.group.setAttribute('tabindex', '0');
          node.group.setAttribute('aria-label', cat.category);
          node.group.addEventListener('click', () => {
            expanded = expanded === idx ? null : idx;
            render().catch((error) => {
              console.error('Failed to render dataset after category toggle', error);
            });
          });
          node.group.addEventListener('keypress', (evt) => {
            if (evt.key === 'Enter' || evt.key === ' ') {
              evt.preventDefault();
              expanded = expanded === idx ? null : idx;
              render().catch((error) => {
                console.error('Failed to render dataset after keyboard toggle', error);
              });
            }
          });
        } else {
          node.group.setAttribute('aria-label', cat.category);
          if (searchMeta[idx] && (searchMeta[idx].catNameMatch || searchMeta[idx].hasItemMatch || searchMeta[idx].hasGroupMatch)) {
            node.group.classList.add('search-hit');
          }
        }
        catNodes[idx] = { ...node, pos, cat };
      });

      const rootBranches = group(connectorsLayer);
      visibleIndices.forEach((idx) => {
        const node = catNodes[idx];
        if (!node) return;
        const { pos, cat } = node;
        const startX = pos.side === 'right' ? rootNode.x + rootNode.rx : rootNode.x - rootNode.rx;
        const startY = rootNode.y;
        const endX = pos.side === 'right' ? pos.x - node.rx : pos.x + node.rx;
        const endY = pos.y;
        const ctrlX = startX + (endX - startX) * 0.5;
        path(
          rootBranches,
          `M ${startX} ${startY} C ${ctrlX} ${startY}, ${ctrlX} ${endY}, ${endX} ${endY}`,
          { stroke: cat.color, sw: 2, op: 0.45 }
        );
      });

      const highlightLayer = group(connectorsLayer);

      visibleIndices.forEach((idx) => {
        const node = catNodes[idx];
        if (!node) return;
        const { cat, pos } = node;
        const meta = searchActive ? searchMeta[idx] : null;
        const shouldExpand = searchActive ? !!(meta && (meta.hasItemMatch || meta.hasGroupMatch)) : expanded === idx;
        if (!shouldExpand) return;

        const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
        highlight.setAttribute('cx', node.x);
        highlight.setAttribute('cy', node.y);
        highlight.setAttribute('rx', node.rx + 28);
        highlight.setAttribute('ry', node.ry + 24);
        highlight.setAttribute('fill', 'none');
        highlight.setAttribute('stroke', cat.color);
        highlight.setAttribute('stroke-opacity', '0.55');
        highlight.setAttribute('stroke-dasharray', '8 12');
        highlightLayer.appendChild(highlight);

        const entries = Array.isArray(cat.items) ? cat.items : [];
        const groupState = searchActive ? null : getGroupState(cat, activeLang);
        const branches = [];

        entries.forEach((entry, entryIdx) => {
          if (isGroup(entry)) {
            const items = Array.isArray(entry.items) ? entry.items : [];
            if (searchActive) {
              const branchMeta = meta && meta.branchInfos ? meta.branchInfos[entryIdx] : null;
              if (!branchMeta || !branchMeta.hasMatch) return;
              const matchedItems = branchMeta.items.filter((info) => info.match).map((info) => info.entry);
              branches.push({
                type: 'group',
                entry,
                items: matchedItems,
                expanded: true,
                slots: 1 + matchedItems.length,
                meta: branchMeta,
              });
            } else {
              const expandedGroup = groupState.has(entry.group);
              branches.push({
                type: 'group',
                entry,
                items,
                expanded: expandedGroup,
                slots: expandedGroup ? 1 + items.length : 1,
              });
            }
          } else if (entry && entry.name) {
            if (searchActive) {
              const branchMeta = meta && meta.branchInfos ? meta.branchInfos[entryIdx] : null;
              if (!branchMeta || !branchMeta.match) return;
              branches.push({ type: 'item', entry, slots: 1, highlight: true });
            } else {
              branches.push({ type: 'item', entry, slots: 1 });
            }
          }
        });

        const totalSlots = branches.reduce((sumSlots, branch) => sumSlots + branch.slots, 0);
        if (!totalSlots) return;

        const branchHeight = ITEM_SPACING * Math.max(0, totalSlots - 1);
        const startY = node.y - branchHeight / 2;
        const branchConnectors = group(connectorsLayer);
        const nestedConnectors = group(connectorsLayer);
        const groupLayer = group(nodesLayer);
        const leafLayer = group(nodesLayer);

        let slotCursor = 0;
        branches.forEach((branch) => {
          if (branch.type === 'group') {
            const groupX = pos.side === 'right' ? pos.x + GROUP_GAP : pos.x - GROUP_GAP;
            const groupY = startY + slotCursor * ITEM_SPACING;
            const hasItems = branch.items.length > 0;
            const indicator = searchActive ? (hasItems ? '‚ñæ' : '‚Ä¢') : branch.expanded ? '‚ñæ' : '‚ñ∏';
            const labelText = branch.entry.group ? `${indicator} ${branch.entry.group}` : indicator;
            const groupNode = createNode(groupLayer, groupX, groupY, labelText, {
              fill: palette.surface,
              stroke: cat.color,
              sw: 1.6,
              padX: 20,
              padY: 12,
              cls: 'small',
            });
            if (!searchActive) {
              groupNode.group.style.cursor = 'pointer';
              groupNode.group.setAttribute('role', 'button');
              groupNode.group.setAttribute('tabindex', '0');
              groupNode.group.setAttribute('aria-label', branch.entry.group);
              groupNode.group.setAttribute('aria-expanded', branch.expanded ? 'true' : 'false');
              const toggleGroup = () => {
                if (groupState.has(branch.entry.group)) {
                  groupState.delete(branch.entry.group);
                } else {
                  groupState.add(branch.entry.group);
                }
                render().catch((error) => {
                  console.error('Failed to render dataset after group toggle', error);
                });
              };
              groupNode.group.addEventListener('click', toggleGroup);
              groupNode.group.addEventListener('keypress', (evt) => {
                if (evt.key === 'Enter' || evt.key === ' ') {
                  evt.preventDefault();
                  toggleGroup();
                }
              });
            } else if (branch.meta && (branch.meta.groupNameMatch || branch.items.length)) {
              groupNode.group.classList.add('search-hit');
            }

            const startBranchX = pos.side === 'right' ? node.x + node.rx : node.x - node.rx;
            const endBranchX = pos.side === 'right' ? groupX - groupNode.rx : groupX + groupNode.rx;
            const ctrlBranchX = startBranchX + (endBranchX - startBranchX) * 0.6;
            path(
              branchConnectors,
              `M ${startBranchX} ${node.y} C ${ctrlBranchX} ${node.y}, ${ctrlBranchX} ${groupY}, ${endBranchX} ${groupY}`,
              { stroke: cat.color, sw: 1.6, op: 0.6 }
            );

            const itemsToRender = searchActive ? branch.items : branch.expanded ? branch.items : [];
            itemsToRender.forEach((svc, svcIdx) => {
              const slotIndex = slotCursor + 1 + svcIdx;
              const itemY = startY + slotIndex * ITEM_SPACING;
              const itemX = pos.side === 'right' ? pos.x + ITEM_GAP : pos.x - ITEM_GAP;
              const label = formatLabel(svc.name);
              const itemNode = createNode(leafLayer, itemX, itemY, label, {
                fill: palette.surface,
                stroke: cat.color,
                sw: 1.5,
                padX: 20,
                padY: 12,
                cls: 'small',
              });
              if (searchActive) {
                itemNode.group.classList.add('search-hit');
              }
              itemNode.group.style.cursor = 'pointer';
              itemNode.group.setAttribute('aria-label', svc.name);
              itemNode.group.addEventListener('mouseenter', () =>
                showTip(itemX, itemY, label, svc.desc, svc.href)
              );
              itemNode.group.addEventListener('mouseleave', hideTip);
              itemNode.group.addEventListener('click', () => window.open(svc.href, '_blank'));
              const startNestedX = pos.side === 'right' ? groupNode.x + groupNode.rx : groupNode.x - groupNode.rx;
              const endNestedX = pos.side === 'right' ? itemX - itemNode.rx : itemX + itemNode.rx;
              const ctrlNestedX = startNestedX + (endNestedX - startNestedX) * 0.6;
              path(
                nestedConnectors,
                `M ${startNestedX} ${groupY} C ${ctrlNestedX} ${groupY}, ${ctrlNestedX} ${itemY}, ${endNestedX} ${itemY}`,
                { stroke: cat.color, sw: 1.4, op: 0.55 }
              );
            });

            slotCursor += branch.slots;
          } else {
            const svc = branch.entry;
            const itemY = startY + slotCursor * ITEM_SPACING;
            const itemX = pos.side === 'right' ? pos.x + ITEM_GAP : pos.x - ITEM_GAP;
            const label = formatLabel(svc.name);
            const itemNode = createNode(leafLayer, itemX, itemY, label, {
              fill: palette.surface,
              stroke: cat.color,
              sw: 1.5,
              padX: 20,
              padY: 12,
              cls: 'small',
            });
            if (searchActive && branch.highlight) {
              itemNode.group.classList.add('search-hit');
            }
            itemNode.group.style.cursor = 'pointer';
            itemNode.group.setAttribute('aria-label', svc.name);
            itemNode.group.addEventListener('mouseenter', () =>
              showTip(itemX, itemY, label, svc.desc, svc.href)
            );
            itemNode.group.addEventListener('mouseleave', hideTip);
            itemNode.group.addEventListener('click', () => window.open(svc.href, '_blank'));
            const startBranchX = pos.side === 'right' ? node.x + node.rx : node.x - node.rx;
            const endBranchX = pos.side === 'right' ? itemX - itemNode.rx : itemX + itemNode.rx;
            const ctrlBranchX = startBranchX + (endBranchX - startBranchX) * 0.6;
            path(
              branchConnectors,
              `M ${startBranchX} ${node.y} C ${ctrlBranchX} ${node.y}, ${ctrlBranchX} ${itemY}, ${endBranchX} ${itemY}`,
              { stroke: cat.color, sw: 1.6, op: 0.6 }
            );

            slotCursor += branch.slots;
          }
        });
      });
    }


    // Init
    applyThemeAttributes(theme);
    setLang(lang).catch((error) => {
      console.error('Failed to initialize language', error);
    });
  </script>
</body>
</html>
